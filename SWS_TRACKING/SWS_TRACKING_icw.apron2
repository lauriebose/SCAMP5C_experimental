>apron
{
    >code
    {
        | // s5c-make icw
        p| !include('scamp5c/scamp5c_compile_config.aps')
        +| 
        +p| !sim_core('cores/core_scamp5b_mod.dll')
        +| 
        +p| !operator(=, load)
        +p| !operator(+, _invalid_operator )
        +p| !operator(-, _invalid_operator )
        +p| !operator(*, _invalid_operator )
        +p| !operator(/, _invalid_operator )
        +| 
        +p| !generate_icw_file
        +p| !max_addr(2000)
        +| 
        +p| !define(SPI_APP_TEXT_NOT_AVAILABLE, 0)
        +p| !define(SPI_APP_TEXT_UNDEFINED, 1)
        +p| !define(SPI_APP_TEXT_SWITCH, 2)
        +p| !define(SPI_APP_TEXT_MODE, 3)
        +p| !define(SPI_APP_TEXT_THRESHOLD_A, 4)
        +p| !define(SPI_APP_TEXT_THRESHOLD_B, 5)
        +p| !define(SPI_APP_TEXT_THRESHOLD_C, 6)
        +p| !define(SPI_APP_TEXT_THRESHOLD_D, 7)
        +| 
        +p| !define(SPI_APP_TEXT_X, 8)
        +p| !define(SPI_APP_TEXT_Y, 9)
        +p| !define(SPI_APP_TEXT_X_SHIFT, 10)
        +p| !define(SPI_APP_TEXT_Y_SHIFT, 11)
        +p| !define(SPI_APP_TEXT_X_MASK, 12)
        +p| !define(SPI_APP_TEXT_Y_MASK, 13)
        +p| !define(SPI_APP_TEXT_X_MATCH, 14)
        +p| !define(SPI_APP_TEXT_Y_MATCH, 15)
        +| 
        +p| !define(SPI_APP_TEXT_INPUT_0, 16)
        +p| !define(SPI_APP_TEXT_INPUT_1, 17)
        +p| !define(SPI_APP_TEXT_INPUT_2, 18)
        +p| !define(SPI_APP_TEXT_INPUT_3, 19)
        +p| !define(SPI_APP_TEXT_ITERATION_I, 20)
        +p| !define(SPI_APP_TEXT_ITERATION_J, 21)
        +p| !define(SPI_APP_TEXT_EXPOSURE, 22)
        +p| !define(SPI_APP_TEXT_DIFFUSION, 23)
        +| 
        +p| !define(SPI_APP_TEXT_E, 24)
        +p| !define(SPI_APP_TEXT_F, 25)
        +p| !define(SPI_APP_TEXT_G, 26)
        +p| !define(SPI_APP_TEXT_H, 27)
        +p| !define(SPI_APP_TEXT_T, 28)
        +p| !define(SPI_APP_TEXT_U, 29)
        +p| !define(SPI_APP_TEXT_V, 30)
        +p| !define(SPI_APP_TEXT_W, 31)
        +| 
        +p| !define(USE_CALL_USB_AOUT_256_COL_MAJOR, 0)
        +p| !define(USE_CALL_USB_AOUT_256_ROW_MAJOR, 1)
        +p| !define(USE_CALL_USB_DOUT_256_ROW_MAJOR, 1)
        +p| !define(USE_CALL_SPI_AOUT_ROW_MAJOR, 1)
        +p| !define(USE_CALL_SPI_DOUT_ROW_MAJOR, 1)
        +| 
        +p| !define(INPUT_CHANNEL_1, IPU_PORT_INPUT_1)
        +p| !define(INPUT_CHANNEL_2, IPU_PORT_INPUT_2)
        +p| !define(INPUT_CHANNEL_3, IPU_PORT_INPUT_3)
        +p| !define(INPUT_CHANNEL_4, IPU_PORT_INPUT_4)
        +p| !define(INPUT_CHANNEL_5, IPU_PORT_INPUT_5)
        +| 
        +p| !define(ROW_STREAM, 0)
        +p| !define(COL_STREAM, 1)
        +| 
        c| apron.config_begin
        m|     sim.pix_source_webcam
        +|     // ignored
        c|     host.set_frame_rate(30)
        c|     window_1 = host.add_display('W1')
        c|     window_2 = host.add_display('W2')
        c|      window_3 = host.add_display('W3')
        c|     slider_1 = host.add_slider('threshold', -120, 120, -120)
        c|     slider_2 = host.add_slider('flood_iterations', 1, 10, 4)
        |     
        |     
        c|     data_1 = host.add_datasheet('coords',1,2,ROW_STREAM)
        c| apron.config_end
        | 
        p| !include('scamp5c/scamp5c_framework.aps')
        +| 
        +p| !include('scamp5c/scamp5c_pe_def.aps')
        ++| 
        ++| // SCAMP-5 PE Registers
        ++| //------------------------------------------------------------------------------
        ++| 
        ++p| !object('ar', 'ar', 0, 'SIM_REGISTER')
        ++p| !object('dr', 'dr', 1, 'SIM_REGISTER')
        ++p| !object('ipuvar', 'iv', 2, 'SIM_VARIABLE')
        ++| 
        ++p| !define(AR, 'ar')
        ++p| !define(DR, 'dr')
        ++p| !define(IPUVAR, 'ipuvar')
        ++| 
        ++p| !create('A', AR, 128, 128)// nResourceID == 0
        ++p| !create('B', AR, 128, 128)
        ++p| !create('C', AR, 128, 128)
        ++p| !create('D', AR, 128, 128)
        ++p| !create('E', AR, 128, 128)
        ++p| !create('F', AR, 128, 128)
        ++p| !create('NEWS', AR, 128, 128)// nResourceID == 6
        ++p| !create('PIX', AR, 128, 128)
        ++p| !create('IN', AR, 128, 128)
        ++p| !create('NORTH', AR, 128, 128)// nResourceID == 9
        ++p| !create('SOUTH', AR, 128, 128)
        ++p| !create('EAST', AR, 128, 128)
        ++p| !create('WEST', AR, 128, 128)
        ++| 
        ++p| !define(A, ar[A])
        ++p| !define(B, ar[B])
        ++p| !define(C, ar[C])
        ++p| !define(D, ar[D])
        ++p| !define(E, ar[E])
        ++p| !define(F, ar[F])
        ++p| !define(NEWS, ar[NEWS])
        ++p| !define(PIX, ar[PIX])
        ++p| !define(IN, ar[IN])
        ++p| !define(NORTH, ar[NORTH])
        ++p| !define(SOUTH, ar[SOUTH])
        ++p| !define(WEST, ar[WEST])
        ++p| !define(EAST, ar[EAST])
        ++| 
        ++p| !create('R0', DR, 128, 128)// nResourceID == 0
        ++p| !create('R1', DR, 128, 128)
        ++p| !create('R2', DR, 128, 128)
        ++p| !create('R3', DR, 128, 128)
        ++p| !create('R4', DR, 128, 128)
        ++p| !create('R5', DR, 128, 128)
        ++p| !create('R6', DR, 128, 128)
        ++p| !create('R7', DR, 128, 128)
        ++p| !create('R8', DR, 128, 128)
        ++p| !create('R9', DR, 128, 128)
        ++p| !create('R10', DR, 128, 128)
        ++p| !create('R11', DR, 128, 128)
        ++p| !create('R12', DR, 128, 128)
        ++p| !create('FLAG', DR, 128, 128)// nResourceID == 13
        ++| 
        ++p| !define(FLAG,dr[FLAG])
        ++p| !define(RANA,dr[FLAG])
        ++p| !define(FL,dr[R0])
        ++p| !define(R0,dr[R0])
        ++p| !define(R1,dr[R1])
        ++p| !define(R2,dr[R2])
        ++p| !define(R3,dr[R3])
        ++p| !define(R4,dr[R4])
        ++p| !define(R5,dr[R5])
        ++p| !define(R6,dr[R6])
        ++p| !define(R7,dr[R7])
        ++p| !define(R8,dr[R8])
        ++p| !define(R9,dr[R9])
        ++p| !define(R10,dr[R10])
        ++p| !define(R11,dr[R11])
        ++p| !define(R12,dr[R12])
        ++| 
        ++| 
        ++| 
        ++| // SCAMP-5 ICW Bits
        ++| //------------------------------------------------------------------------------
        ++| 
        ++p| !define(xSELSQ, 0)
        ++p| !define(xSPIX, 1)
        ++p| !define(xRPIX, 2)
        ++p| !define(xSELDIFFE, 3)
        ++p| !define(xSELDIFFS, 4)
        ++p| !define(xSIN, 5)
        ++p| !define(xRANA, 6)
        ++p| !define(xSELS, 7)
        ++p| !define(xSELE, 8)
        ++p| !define(xSELX, 9)
        ++p| !define(xRID, 10)
        ++p| !define(xSELN, 11)
        ++p| !define(xWRF, 12)
        ++p| !define(xSETF, 13)
        ++p| !define(xSELW, 14)
        ++p| !define(xPUPD, 15)
        ++p| !define(xFLOAT, 16)
        ++p| !define(xLFL, 17)
        ++p| !define(xRFL, 18)
        ++p| !define(xNBIT, 19)
        ++p| !define(xNB, 20)
        ++p| !define(xPLWB, 21)
        ++p| !define(xPLRB, 22)
        ++p| !define(xBIT, 23)
        ++p| !define(xBITMODE, 24)
        ++p| !define(xWR, 25)
        ++p| !define(xANA, 26)
        ++p| !define(xDIG8, 27)
        ++p| !define(xG_START, 28)
        ++p| !define(xg_STOP, 29)
        ++p| !define(xCOL_OUT, 30)
        ++p| !define(xDIR, 31)
        ++p| !define(xROW_OUT, 32)
        ++p| !define(xS0_LEFT, 33)
        ++p| !define(xS1_LEFT, 34)
        ++p| !define(xRST_START, 35)
        ++p| !define(xRST_STOP, 36)
        ++p| !define(xS0_BOT, 37)
        ++p| !define(xS1_BOT, 38)
        ++p| !define(xPGDB, 39)
        ++p| !define(xPGDBOBUS, 40)
        ++| 
        ++p| !define(xW1, 41)
        ++p| !define(xW2, 42)
        ++p| !define(xW3, 43)
        ++p| !define(xW4, 44)
        ++p| !define(xW5, 45)
        ++p| !define(xW6, 45)
        ++p| !define(xW7, 47)
        ++p| !define(xSEL1, 48)
        ++p| !define(xSEL2, 49)
        ++p| !define(xSEL3, 50)
        ++p| !define(xSEL4, 51)
        ++p| !define(xSEL5, 52)
        ++p| !define(xSEL6, 53)
        ++p| !define(xSEL7, 54)
        ++| 
        ++| //It's for the bits in Macro.	macro(A) will translate to ar[A] in the macro. As a result just define 
        ++| //xW1 is not enough. xWar[A] is needed. In normal code (not in a macro), set(xW1) can be used.
        ++p| !define(xWar[A], 41)
        ++p| !define(xWar[B], 42)
        ++p| !define(xWar[C], 43)
        ++p| !define(xWar[NEWS], 44)
        ++p| !define(xWar[D], 45)
        ++p| !define(xWar[E], 45)
        ++p| !define(xWar[F], 47)
        ++p| !define(xSELar[A], 48)
        ++p| !define(xSELar[B], 49)
        ++p| !define(xSELar[C], 50)
        ++p| !define(xSELar[NEWS], 51)
        ++p| !define(xSELar[D], 52)
        ++p| !define(xSELar[E], 53)
        ++p| !define(xSELar[F], 54)
        ++| 
        ++p| !define(xRR1, 55)
        ++p| !define(xRR2, 56)
        ++p| !define(xRR3, 57)
        ++p| !define(xRR4, 58)
        ++p| !define(xRR5, 59)
        ++p| !define(xRR6, 60)
        ++p| !define(xRR7, 61)
        ++p| !define(xRR8, 62)
        ++p| !define(xRR9, 63)
        ++p| !define(xRR10, 64)
        ++p| !define(xRR11, 65)
        ++p| !define(xRR12, 66)
        ++p| !define(xLR1, 67)
        ++p| !define(xLR2, 68)
        ++p| !define(xLR3, 69)
        ++p| !define(xLR4, 70)
        ++p| !define(xLR5, 71)
        ++p| !define(xLR6, 72)
        ++p| !define(xLR7, 73)
        ++p| !define(xLR8, 74)
        ++p| !define(xLR9, 75)
        ++p| !define(xLR10, 76)
        ++p| !define(xLR11, 77)
        ++p| !define(xLR12, 78)
        ++| 
        ++| //It's for the bits in Macro.	macro(R1) will translate to ar[R1] in the macro. As a result just define 
        ++| //xRR1 is not enough. xRdr[R1] is needed. In normal code (not in a macro), set(xW1) can be used.
        ++p| !define(xRdr[R1], 55)
        ++p| !define(xRdr[R2], 56)
        ++p| !define(xRdr[R3], 57)
        ++p| !define(xRdr[R4], 58)
        ++p| !define(xRdr[R5], 59)
        ++p| !define(xRdr[R6], 60)
        ++p| !define(xRdr[R7], 61)
        ++p| !define(xRdr[R8], 62)
        ++p| !define(xRdr[R9], 63)
        ++p| !define(xRdr[R10], 64)
        ++p| !define(xRdr[R11], 65)
        ++p| !define(xRdr[R12], 66)
        ++p| !define(xLdr[R1], 67)
        ++p| !define(xLdr[R2], 68)
        ++p| !define(xLdr[R3], 69)
        ++p| !define(xLdr[R4], 70)
        ++p| !define(xLdr[R5], 71)
        ++p| !define(xLdr[R6], 72)
        ++p| !define(xLdr[R7], 73)
        ++p| !define(xLdr[R8], 74)
        ++p| !define(xLdr[R9], 75)
        ++p| !define(xLdr[R10], 76)
        ++p| !define(xLdr[R11], 77)
        ++p| !define(xLdr[R12], 78)
        ++| 
        +p| !include('scamp5c/scamp5c_pe_macro.aps')
        ++| //
        ++| // SCAMP-5 PE Operation Macros 
        ++| //
        ++| // Assume analog register F and digital register R0 to be volatile
        ++| //
        ++| //------------------------------------------------------------------------------
        ++| 
        ++| // reset pix to min level
        ++p| !macro_def
        ++pg|     pe.rpix
        ++pg| !macro_begin
        ++p|     respix
        ++p|     respix
        ++p| !macro_end
        ++| 
        ++| // reset pix to min level and save its value
        ++p| !macro_def
        ++pg|     pe.rpix($r1)
        ++pg| !macro_begin
        ++p|     respix
        ++p|     respix
        ++p|     nop
        ++p|     F = PIX
        ++p|     $r1 = F
        ++p| !macro_end
        ++| 
        ++| // $r1 will be a half-toned image, $r2 will be a full range image
        ++p| !macro_def
        ++pg|     pe.rpix($r1,$r2)
        ++pg| !macro_begin
        ++p|     $r1 = PIX
        ++p|     F = PIX
        ++p|     respix
        ++p|     nop
        ++p|     $r2 = load($r1 F PIX)
        ++p|     $r1 = load(F PIX)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     pe.cpix($r1,$r2,$r3)
        ++pg| !macro_begin
        ++p|     $r1 = PIX
        ++p|     F = PIX
        ++p|     $r2 = load($r1 F $r3)
        ++p|     $r1 = F
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = pe.copy($r2)
        ++pg| !macro_begin
        ++p|     F = $r2
        ++p|     $r1 = F
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = pe.add($r2,$r3)
        ++pg| !macro_begin
        ++p|     F = load($r2 $r3)
        ++p|     $r1 = F
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     pe.add($r1,$r2)
        ++pg| !macro_begin
        ++p|     F = load($r1 $r2)
        ++p|     $r1 = F
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = pe.sub($r2,$r3)
        ++pg| !macro_begin
        ++p|     F = $r2
        ++p|     $r1 = load(F $r3)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     pe.sub($r2,$r3)
        ++pg| !macro_begin
        ++p|     F = $r2
        ++p|     $r2 = load(F $r3)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = pe.neg($r2)
        ++pg| !macro_begin
        ++p|     res(F)
        ++p|     $r1 = load($r2 F)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = pe.abs($r2)
        ++pg| !macro_begin
        ++p|     $r1 = $r2
        ++p|     F = $r2
        ++p|     where($r2)
        ++p|         $r1 = F
        ++p|     all
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     pe.div($r1,$r2,$r3)
        ++pg| !macro_begin
        ++p|     $r2 $r3 = $r1
        ++p|     F = load($r1 $r3)
        ++p|     $r3 = load(F $r2)
        ++p|     $r2 F = $r3
        ++p|     $r2 = F
        ++p|     $r3 = F
        ++p|     // under testing
        ++p| !macro_end
        ++| 
        ++| //A destructive division macro. $r3 = $r3/2 under testing
        ++p| !macro_def
        ++pg|     pe.d_div($r1,$r2,$r3) 
        ++pg| !macro_begin
        ++p|     $r2 $r3 = $r1
        ++p|     F = load($r1 $r3)
        ++p|     $r1 = load(F $r2)
        ++p|     $r2 $r3 = $r1
        ++p|     $r1 = $r3
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = pe.in($v)
        ++pg| !macro_begin
        ++p|     _mov(su,$v)
        ++p|     _exp(128, IPU_PORT_B)// I resend this every time since oughta keep transitions the same. 
        ++p|      set('sin') //drags the bus to the IN level.
        ++p|     _add(su,128)
        ++p|     F = IN
        ++p|     _exp(su, IPU_PORT_B)
        ++p|     $r1 = F IN
        ++p| !macro_end
        ++| 
        ++| 
        ++p| !macro_def
        ++pg|     $r1 = pe.north($r2)
        ++pg| !macro_begin
        ++p|     //R0 = FLAG
        ++p|     //all
        ++p|     NEWS = $r2
        ++p|     //where(R0)
        ++p|     $r1 = NORTH
        ++p| !macro_end
        ++| 
        ++| 
        ++p| !macro_def
        ++pg|     $r1 = pe.east($r2)
        ++pg| !macro_begin
        ++p|     NEWS = $r2
        ++p|     $r1 = EAST
        ++p| !macro_end
        ++| 
        ++| 
        ++p| !macro_def
        ++pg|     $r1 = pe.west($r2)
        ++pg| !macro_begin
        ++p|     NEWS = $r2
        ++p|     $r1 = WEST
        ++p| !macro_end
        ++| 
        ++| 
        ++p| !macro_def
        ++pg|     $r1 = pe.south($r2)
        ++pg| !macro_begin
        ++p|     NEWS = $r2
        ++p|     $r1 = SOUTH
        ++p| !macro_end
        ++| 
        ++| 
        ++p| !macro_def
        ++pg|     $r1 = pe.d2a($r2)
        ++pg| !macro_begin
        ++p|     all
        ++p|     set('plrb' 'rid') //this drives the bus to zero volts
        ++p|     _exp(0,IPU_PORT_B)
        ++p|     $r1 = IN
        ++p|     where($r2)
        ++p|         set('plrb' 'rid') //this drives the bus to zero volts
        ++p|         _exp(255, IPU_PORT_B)
        ++p|         $r1 = IN
        ++p|     all
        ++p| !macro_end
        ++| 
        ++| 
        ++| 
        ++| // Digital Operation Macros (R0 is volatile)
        ++| //------------------------------------------------------------------------------
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = pe.not($r2)
        ++pg| !macro_begin
        ++p|     $r1 = not($r2)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = pe.or($r2,$r3)
        ++pg| !macro_begin
        ++p|     $r1 = load($r2,$r3)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = pe.nor($r2,$r3)
        ++pg| !macro_begin
        ++p| //  set(xPLRB xNBIT xL$r1 xR$r2 xR$r3) 
        ++p|     R0 = load($r2,$r3)
        ++p|     $r1 = not(R0)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = pe.and($r2,$r3)
        ++pg| !macro_begin
        ++p|     $r1 = not($r2)
        ++p|     $r2 = not($r3)
        ++p|     R0 = load($r1,$r2)
        ++p|     $r2 = not($r1)
        ++p|     $r1 = not(R0)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = pe.nand($r2,$r3)
        ++pg| !macro_begin
        ++p|     R0 = not($r2) //invert both inputs
        ++p|     $r2 = not($r3) 
        ++p|     set(xPLRB xBIT xBITMODE xL$r1 xRFL xR$r2) 
        ++p|     $r2 = not(R0) //re-instating R$r2
        ++p| !macro_end
        ++| 
        ++| // clear first DREG if second DREG is 1
        ++p| !macro_def
        ++pg|     pe.clr_if($r1,$r2)
        ++pg| !macro_begin
        ++p|     R0 = $r1
        ++p|     $r1 = not(R0)
        ++p|     R0 = or($r1,$r2)
        ++p|     $r1 = not(R0)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     pe.refresh($r1)
        ++pg| !macro_begin
        ++p|     R0 = $r1
        ++p|     $r1 = R0
        ++p| !macro_end
        ++| 
        ++| // check if first DREG is 0 and second DREG is 1
        ++p| !macro_def
        ++pg|     $out = pe.pattern_0_1($r1,$r2)
        ++pg| !macro_begin
        ++p|     $out = not($r2)
        ++p|     R0 = or($r1,$out)
        ++p|     $out = not(R0)
        ++p| !macro_end
        ++| 
        ++| // 
        ++p| !macro_def
        ++pg|     $r1 = pe.a2d($r2)
        ++pg| !macro_begin
        ++p|     where($r2)
        ++p|     $r1 = load(FLAG)
        ++p|     all
        ++p| !macro_end
        ++| 
        ++| 
        ++| 
        ++| // Alternative Name
        ++| //------------------------------------------------------------------------------
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     rpix($r1,$r2)
        ++pg| !macro_begin
        ++p|     pe.rpix($r1,$r2)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     rpix($r1)
        ++pg| !macro_begin
        ++p|     pe.rpix($r1)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     rpix
        ++pg| !macro_begin
        ++p|     pe.rpix
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     cpix($r1,$r2,$r3)
        ++pg| !macro_begin
        ++p|     pe.cpix($r1,$r2,$r3)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $a = in($p)
        ++pg| !macro_begin
        ++p|     $a = pe.in($p)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = copy($r2)
        ++pg| !macro_begin
        ++p|     $r1 = pe.copy($r2)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = add($r2,$r3)
        ++pg| !macro_begin
        ++p|     $r1 = pe.add($r2,$r3)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     add($r2,$r3)
        ++pg| !macro_begin
        ++p|     pe.add($r2,$r3)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = sub($r2,$r3)
        ++pg| !macro_begin
        ++p|     $r1 = pe.sub($r2,$r3)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     sub($r2,$r3)
        ++pg| !macro_begin
        ++p|     pe.sub($r2,$r3)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     div($r1,$r2,$r3)
        ++pg| !macro_begin
        ++p|     pe.div($r1,$r2,$r3)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = neg($r2)
        ++pg| !macro_begin
        ++p|     $r1 = pe.neg($r2)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = abs($r2)
        ++pg| !macro_begin
        ++p|     $r1 = pe.abs($r2)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = north($r2)
        ++pg| !macro_begin
        ++p|     $r1 = pe.north($r2)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = east($r2)
        ++pg| !macro_begin
        ++p|     $r1 = pe.east($r2)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = west($r2)
        ++pg| !macro_begin
        ++p|     $r1 = pe.west($r2)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = south($r2)
        ++pg| !macro_begin
        ++p|     $r1 = pe.south($r2)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = or($r2,$r3)
        ++pg| !macro_begin
        ++p|     $r1 = pe.or($r2,$r3)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = nor($r2,$r3)
        ++pg| !macro_begin
        ++p|     $r1 = pe.nor($r2,$r3)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = and($r2,$r3)
        ++pg| !macro_begin
        ++p|     $r1 = pe.and($r2,$r3)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = nand($r2,$r3)
        ++pg| !macro_begin
        ++p|     $r1 = pe.nand($r2,$r3)
        ++p| !macro_end
        ++| 
        ++| 
        ++| 
        ++| // Deprecated Name
        ++| //------------------------------------------------------------------------------
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     F.rpix
        ++pg| !macro_begin
        ++p|     pe.rpix
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     F.rpix($r1,$r2)
        ++pg| !macro_begin
        ++p|     pe.rpix($r1,$r2)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $a = F.in($p)
        ++pg| !macro_begin
        ++p|     $a = pe.in($p)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = F.mov($r2)
        ++pg| !macro_begin
        ++p|     $r1 = pe.copy($r2)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = F.add($r2,$r3)
        ++pg| !macro_begin
        ++p|     $r1 = pe.add($r2,$r3)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     F.add($r2,$r3)
        ++pg| !macro_begin
        ++p|     pe.add($r2,$r3)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = F.sub($r2,$r3)
        ++pg| !macro_begin
        ++p|     $r1 = pe.sub($r2,$r3)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     F.sub($r2,$r3)
        ++pg| !macro_begin
        ++p|     pe.sub($r2,$r3)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     F.div($r1,$r2,$r3)
        ++pg| !macro_begin
        ++p|     pe.div($r1,$r2,$r3)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = F.abs($r2)
        ++pg| !macro_begin
        ++p|     $r1 = pe.abs($r2)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = F.neg($r2)
        ++pg| !macro_begin
        ++p|     $r1 = pe.neg($r2)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = F.north($r2)
        ++pg| !macro_begin
        ++p|     $r1 = pe.north($r2)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = F.east($r2)
        ++pg| !macro_begin
        ++p|     $r1 = pe.east($r2)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = F.west($r2)
        ++pg| !macro_begin
        ++p|     $r1 = pe.west($r2)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = F.south($r2)
        ++pg| !macro_begin
        ++p|     $r1 = pe.south($r2)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = F.d2a($r2)
        ++pg| !macro_begin
        ++p|     $r1 = pe.d2a($r2)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = L.not($r2)
        ++pg| !macro_begin
        ++p|     $r1 = pe.not($r2)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = L.or($r2,$r3)
        ++pg| !macro_begin
        ++p|     $r1 = pe.or($r2,$r3)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = L.nor($r2,$r3)
        ++pg| !macro_begin
        ++p|     $r1 = pe.nor($r2,$r3)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = L.and($r2,$r3)
        ++pg| !macro_begin
        ++p|     $r1 = pe.and($r2,$r3)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = L.nand($r2,$r3)
        ++pg| !macro_begin
        ++p|     $r1 = pe.nand($r2,$r3)
        ++p| !macro_end
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = L.a2d($r2)
        ++pg| !macro_begin
        ++p|     $r1 = pe.a2d($r2)
        ++p| !macro_end
        ++| 
        +| 
        +p| !include('scamp5c/scamp5c_ipu_def.aps')
        ++| 
        ++| // IPU Register Definitions
        ++| //------------------------------------------------------------------------------
        ++| 
        ++p| !create('s0', IPUVAR)
        ++p| !create('s1', IPUVAR)
        ++p| !create('s2', IPUVAR)
        ++p| !create('s3', IPUVAR)
        ++p| !create('s4', IPUVAR)
        ++p| !create('s5', IPUVAR)
        ++p| !create('s6', IPUVAR)
        ++p| !create('s7', IPUVAR)
        ++p| !create('s8', IPUVAR)
        ++p| !create('s9', IPUVAR)
        ++p| !create('s10', IPUVAR)
        ++p| !create('s11', IPUVAR)
        ++p| !create('s12', IPUVAR)
        ++p| !create('s13', IPUVAR)
        ++p| !create('s14', IPUVAR)
        ++p| !create('s15', IPUVAR)
        ++| 
        ++p| !define(s0, ipuvar[0])
        ++p| !define(s1, ipuvar[1])
        ++p| !define(s2, ipuvar[2])
        ++p| !define(s3, ipuvar[3])
        ++p| !define(s4, ipuvar[4])
        ++p| !define(s5, ipuvar[5])
        ++p| !define(s6, ipuvar[6])
        ++p| !define(s7, ipuvar[7])
        ++p| !define(s8, ipuvar[8])
        ++p| !define(s9, ipuvar[9])
        ++p| !define(s10, ipuvar[10])
        ++p| !define(s11, ipuvar[11])
        ++p| !define(s12, ipuvar[12])
        ++p| !define(s13, ipuvar[13])
        ++p| !define(s14, ipuvar[14])
        ++p| !define(s15, ipuvar[15])
        ++| 
        ++p| !define(su, ipuvar[15])
        ++p| !define(sv, ipuvar[14])
        ++p| !define(sw, ipuvar[13])
        ++p| !define(sx, ipuvar[12])
        ++p| !define(sy, ipuvar[11])
        ++p| !define(sz, ipuvar[10])
        ++| 
        ++| // enumerations
        ++p| !define(c, 1)
        ++p| !define(nc, 2)
        ++p| !define(z, 3)
        ++p| !define(nz, 4)
        ++| 
        ++| 
        ++| // IPU Port Definitions
        ++| //------------------------------------------------------------------------------
        ++| 
        ++p| !define(IPU_PORT_NO_PM_DIN, 128)
        ++p| !define(IPU_PORT_NO_FIFO,   129)
        ++p| !define(IPU_PORT_NO_DBG_CNTR0, 130)
        ++p| !define(IPU_PORT_NO_DBG_CNTR1, 131)
        ++p| !define(IPU_PORT_NO_DBG_CNTR2, 132)
        ++| 
        ++p| !define(IPU_PORT_NO_DBG_CNTR3, 133)
        ++p| !define(IPU_PORT_NO_INT_ADDR0, 134)
        ++p| !define(IPU_PORT_NO_INT_ADDR1, 135)
        ++p| !define(IPU_PORT_PC_DBG_OUT_L, 136)
        ++p| !define(IPU_PORT_PC_DBG_OUT_H, 137)
        ++| 
        ++p| !define(IPU_PORT_ADDR, 138)
        ++p| !define(IPU_PORT_RISE_C1, 139)
        ++p| !define(IPU_PORT_FALL_C1, 140)
        ++p| !define(IPU_PORT_RISE_C2, 141)
        ++p| !define(IPU_PORT_FALL_C2, 142)
        ++p| !define(IPU_PORT_RISE_C3, 143)
        ++p| !define(IPU_PORT_FALL_C3, 144)
        ++p| !define(IPU_PORT_RISE_C4, 145)
        ++p| !define(IPU_PORT_FALL_C4, 146)
        ++p| !define(IPU_PORT_FRAME_CNT_B0, 147)
        ++p| !define(IPU_PORT_FRAME_CNT_B1, 148)
        ++p| !define(IPU_PORT_FRAME_CNT_B2, 149)
        ++| 
        ++p| !define(IPU_PORT_NO_SOFT_RST, 151)
        ++| 
        ++p| !define(IPU_PORT_NO_USB_FLAGS, 224)  // The data at this port is (0 0 0 0 0 0 rxe txf)
        ++p| !define(IPU_PORT_NO_VC_DI, 225)
        ++p| !define(IPU_PORT_NO_IPU_DO, 226)
        ++| 
        ++p| !define(IPU_PORT_FB_X,227)   
        ++p| !define(IPU_PORT_FB_Y,228)   
        ++p| !define(IPU_PORT_FB_D,229)   
        ++p| !define(IPU_PORT_FB_X_MIN,230)
        ++p| !define(IPU_PORT_FB_X_MAX,231)  
        ++p| !define(IPU_PORT_FB_Y_MIN,232)
        ++p| !define(IPU_PORT_FB_Y_MAX,233)
        ++p| !define(IPU_PORT_VC_DI_DIG8,234)
        ++p| !define(IPU_PORT_FT_IN,235)
        ++| 
        ++p| !define(IPU_PORT_ADC_DELAY,236)
        ++p| !define(IPU_PORT_ADC_START_SAMPLE,237)
        ++p| !define(IPU_PORT_ADC_STOP_SAMPLE,238)
        ++p| !define(IPU_PORT_B,239)
        ++p| !define(IPU_PORT_LC,240)
        ++p| !define(IPU_PORT_LR,241)
        ++p| !define(IPU_PORT_LCX,242)
        ++p| !define(IPU_PORT_LRX,243)
        ++p| !define(IPU_PORT_RD,244)
        ++p| !define(IPU_PORT_GOR_IN,245)
        ++p| !define(IPU_PORT_ADC_TRI,246)
        ++p| !define(IPU_PORT_CLK_SWITCH,247)
        ++| 
        ++p| !define(IPU_PORT_ADC_FEAMP,248)
        ++p| !define(IPU_PORT_DACS,249)
        ++p| !define(IPU_PORT_DACsLSBs,250)
        ++p| !define(IPU_PORT_calib,251)
        ++p| !define(IPU_PORT_POWER,252)
        ++| 
        ++p| !define(IPU_PORT_INPUT_1, 18)
        ++p| !define(IPU_PORT_INPUT_2, 19)
        ++p| !define(IPU_PORT_INPUT_3, 20)
        ++p| !define(IPU_PORT_INPUT_4, 21)
        ++p| !define(IPU_PORT_INPUT_5, 22)
        ++| 
        ++| 
        ++| 
        ++p| !define(IPU_PORT_SPI_USB_FLAGS, 224)
        ++p| !define(IPU_PORT_SPI_FIFO_SPACE, 226)
        ++p| !define(IPU_PORT_SPI_FIFO_FLUSH, 246)
        ++| 
        ++| 
        ++| // General Purpose Port (Memory) Definitions
        ++| //------------------------------------------------------------------------------
        ++| 
        ++p| !define(IPU_PORT_LOOPC_0, 32)
        ++p| !define(IPU_PORT_LOOPC_1, 33)
        ++p| !define(IPU_PORT_LOOPC_2, 34)
        ++p| !define(IPU_PORT_LOOPC_3, 35)
        ++p| !define(IPU_PORT_GP_BYTE_0, 210)
        ++p| !define(IPU_PORT_GP_BYTE_1, 211)
        ++p| !define(IPU_PORT_GP_BYTE_2, 212)
        ++p| !define(IPU_PORT_GP_BYTE_3, 213)
        ++p| !define(IPU_PORT_SPI_RX_0, 160)
        ++p| !define(IPU_PORT_SPI_RX_1, 161)
        ++p| !define(IPU_PORT_SPI_RX_2, 162)
        ++p| !define(IPU_PORT_SPI_RX_3, 163)
        ++p| !define(IPU_PORT_SPI_RX_4, 164)
        ++p| !define(IPU_PORT_SPI_RX_5, 165)
        ++p| !define(IPU_PORT_SPI_RX_6, 166)
        ++p| !define(IPU_PORT_SPI_RX_7, 167)
        ++| 
        ++| 
        ++| 
        ++| // USB Packet Definitions
        ++| //------------------------------------------------------------------------------
        ++| 
        ++p| !define(PCKT_START, 85)
        ++p| !define(PCKT_ID_PORT_WR, 1)
        ++p| !define(PCKT_ID_PM_WR, 2)
        ++p| !define(PCKT_ID_IPU_START, 3)
        ++p| !define(PCKT_ID_IPU_STOP, 4)
        ++p| !define(PCKT_ID_FRAME, 5)
        ++p| !define(PCKT_ID_BOX, 6)
        ++p| !define(PCKT_ID_X_COORD, 7)
        ++p| !define(PCKT_ID_Y_COORD, 8)
        ++| 
        ++| 
        +p| !include('scamp5c/scamp5c_ipu_macro.aps')
        ++| //
        ++| // IPU Macros
        ++| // 
        ++| // Aliased IPU registers:
        ++| // su -- s15
        ++| // sv -- s14
        ++| // 
        ++| // These macros assume su and sv to be volatile registers.
        ++| // 
        ++| //------------------------------------------------------------------------------
        ++| 
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     ipu.reset_loop_counter
        ++pg| !macro_begin
        ++p|     _exp(0,IPU_PORT_LOOPC_0)
        ++p|     _exp(0,IPU_PORT_LOOPC_1)
        ++p|     _exp(0,IPU_PORT_LOOPC_2)
        ++p|     _exp(0,IPU_PORT_LOOPC_3)
        ++p| !macro_end
        ++| 
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     ipu.inc_loop_counter
        ++pg| !macro_begin
        ++p|     _exp(255, IPU_PORT_CLK_SWITCH)
        ++p|     _nop
        ++p|     
        ++p|     _imp(sw,IPU_PORT_LOOPC_0)
        ++p|     _imp(sx,IPU_PORT_LOOPC_1)
        ++p|     _imp(sy,IPU_PORT_LOOPC_2)
        ++p|     _imp(sz,IPU_PORT_LOOPC_3)
        ++p|     _add(sw,1)
        ++p|     _addc(sx,0)
        ++p|     _addc(sy,0)
        ++p|     _addc(sz,0)
        ++p|     _exp(sw,IPU_PORT_LOOPC_0)
        ++p|     _exp(sx,IPU_PORT_LOOPC_1)
        ++p|     _exp(sy,IPU_PORT_LOOPC_2)
        ++p|     _exp(sz,IPU_PORT_LOOPC_3)
        ++p|     
        ++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        ++p|     _nop
        ++p| !macro_end
        ++| 
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     ipu.delay_1ms
        ++pg| !macro_begin
        ++p|     _mov(su,20)// gives about 1 ms
        ++p|     _call(#_ipu_su_delay_50us)
        ++p|     _nop
        ++p| !macro_end
        ++| 
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     ipu.delay_2ms
        ++pg| !macro_begin
        ++p|     _mov(su,40)
        ++p|     _call(#_ipu_su_delay_50us)
        ++p|     _nop
        ++p| !macro_end
        ++| 
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     ipu.delay_5ms
        ++pg| !macro_begin
        ++p|     _mov(su,100)
        ++p|     _call(#_ipu_su_delay_50us)
        ++p|     _nop
        ++p| !macro_end
        ++| 
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     ipu.delay_500us
        ++pg| !macro_begin
        ++p|     _mov(su,10)
        ++p|     _call(#_ipu_su_delay_50us)
        ++p|     _nop
        ++p| !macro_end
        ++| 
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     ipu.delay_50us_x($p)
        ++pg| !macro_begin
        ++p|     _mov(su,$p)
        ++p|     _call(#_ipu_su_delay_50us)
        ++p|     _nop
        ++p| !macro_end
        ++| 
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     ipu.wait_frame_trigger
        ++pg| !macro_begin
        ++p|     _nop
        ++p|     _nop
        ++p|     
        ++p|     _exp(0, IPU_PORT_B)
        ++p|     keep
        ++p|     set('sin')
        ++p|     
        ++p|     _exp(255, IPU_PORT_CLK_SWITCH)
        ++p|     _exp(1, IPU_PORT_RD)
        ++p|     
        ++p|     // wait for rising edge
        ++p|     :#frame_trig1
        ++p|     _nop
        ++p|     _imp(su,IPU_PORT_FT_IN)
        ++p|     _cmp(su,1)
        ++p|     _jump(nz,:#frame_trig1)
        ++p|     _nop
        ++p|     
        ++p|     // wait for falling edge
        ++p|     :#frame_trig2
        ++p|     _imp(su,IPU_PORT_FT_IN)
        ++p|     _cmp(su,1)
        ++p|     _jump(z,:#frame_trig2)
        ++p|     _nop
        ++p|     
        ++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        ++p|     _exp(0, IPU_PORT_RD)
        ++p|     _nop
        ++p|     
        ++p| !macro_end
        ++| 
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     ipu.set_frame_trigger($p0,$p1)
        ++pg| !macro_begin
        ++p|     _exp($p0,IPU_PORT_FRAME_CNT_B0)
        ++p|     _exp($p1,IPU_PORT_FRAME_CNT_B1)
        ++p|     _exp(0,IPU_PORT_FRAME_CNT_B2)
        ++p| !macro_end
        ++| 
        ++| 
        ++| 
        ++| //------------------------------------------------------------------------------
        ++| 
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     ipu.send_byte($p1)
        ++pg| !macro_begin
        ++p|     :#wait_usb_buffer
        ++p|     // Check buffer has space
        ++p|     _imp(su, IPU_PORT_NO_USB_FLAGS)
        ++p|     _and(su, 1)
        ++p|     _jump(nz,:#wait_usb_buffer)
        ++p|     // Write byte
        ++p|     _exp($p1,IPU_PORT_NO_IPU_DO)
        ++p| !macro_end
        ++| 
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     ipu.pixel_set($r1,$r2,$r3)
        ++pg| !macro_begin
        ++p|     _nop
        ++p|     _mov(sx,$r2)
        ++p|     _mov(sy,$r3)
        ++p|     _call(#_ipu_sa_pixel_set)
        ++p|     _nop
        ++p|     R1 = $r1
        ++p|     $r1 = load(R0 R1)
        ++p| !macro_end
        ++| 
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = ipu.pixel_select($r2,$r3,$r4,$r5)
        ++pg| !macro_begin
        ++p|     _mov(sy,$r3)
        ++p|     _mov(sx,$r2)
        ++p|     _mov(su,$r4)
        ++p|     _mov(sv,$r5)
        ++p|     _call(#_ipu_sa_pixel_select)
        ++p|     _nop
        ++p|     $r1 = load(R0)
        ++p| !macro_end
        ++| 
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     ipu.pixel_filter($r1,$r2,$r3,$r4,$r5)
        ++pg| !macro_begin
        ++p|     _mov(sy,$r3)
        ++p|     _mov(sx,$r2)
        ++p|     _mov(su,$r4)
        ++p|     _mov(sv,$r5)
        ++p|     _call(#_ipu_sa_pixel_select)
        ++p|     _nop
        ++p|     R1 = $r1
        ++p|     R2 = R0
        ++p|     $r1 = and(R1,R2)
        ++p| !macro_end
        ++| 
        ++| 
        ++| //
        ++p| !macro_def
        ++pg|     $r1 = ipu.global_sum($r2,$r3)
        ++pg| !macro_begin
        ++p|     _exp(2, IPU_PORT_CLK_SWITCH) 
        ++p|     _exp(1, IPU_PORT_ADC_DELAY)
        ++p|     
        ++p|     _exp(0, IPU_PORT_ADDR)
        ++p|     _exp(1, IPU_PORT_LR)
        ++p|     _exp(0, IPU_PORT_LR)
        ++p|     _exp(1, IPU_PORT_LC)
        ++p|     _exp(0, IPU_PORT_LC)
        ++p|     _exp(255, IPU_PORT_ADDR)
        ++p|     _exp(1, IPU_PORT_LCX)
        ++p|     _exp(0, IPU_PORT_LCX)
        ++p|     _exp(1, IPU_PORT_LRX)
        ++p|     _exp(0, IPU_PORT_LRX)
        ++p|     _exp($r3,248)// gain
        ++p|     all
        ++p|     keep
        ++p|     set_sel_ana($r2)
        ++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        ++p|     _exp(1, IPU_PORT_RD)// clocks
        ++p|     _nop
        ++p|     _call(#_ipu_sw_sample_ana)
        ++p|     _nop
        ++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        ++p|     _exp(0, IPU_PORT_RD)
        ++p|     _nop
        ++p|     _mov($r1,sw)
        ++p| !macro_end
        ++| 
        ++| 
        ++| //
        ++p| !macro_def 
        ++pg|     $r1 = ipu.full_global_sum($r2)
        ++pg| !macro_begin
        ++p|     keep
        ++p|     set_sel_ana($r2)
        ++p|     _exp(255, IPU_PORT_CLK_SWITCH)
        ++p|     _nop
        ++p|     _mov(su,0)
        ++p|     _mov(sz,0)
        ++p|      _exp(15, IPU_PORT_ADC_FEAMP)
        ++p|     
        ++p|     // Set Block Size
        ++p|     _exp(31 , IPU_PORT_ADDR) //for a 32 x32 block of pixels (1024 pixels total)
        ++p|     _exp(1, IPU_PORT_LRX)
        ++p|     _exp(0, IPU_PORT_LRX)
        ++p|     _exp(1, IPU_PORT_LCX)
        ++p|     _exp(0, IPU_PORT_LCX)
        ++p|     
        ++p|     // Set ADC Delay
        ++p| 
        ++p|     _exp(16, IPU_PORT_ADC_DELAY) //For this algo, the critical factor is how well IN matches calibration (which is based on the other readout routine)
        ++p|     //Increasing speed destroys calibration at high end
        ++p|     _exp(1, IPU_PORT_RD)
        ++p|     _exp(0, IPU_PORT_ADDR) 
        ++p|     _exp(1, IPU_PORT_LR)
        ++p|     _exp(0, IPU_PORT_LR)
        ++p|      _mov(sy, 0)
        ++p|     :#rm_loop_row_low
        ++p|         _nop
        ++p|         _exp(sy, IPU_PORT_ADDR) 
        ++p|         _exp(1, IPU_PORT_LR)
        ++p|         _exp(0, IPU_PORT_LR)
        ++p|          // column address
        ++p|         _mov(sx, 234)
        ++p|         _exp(sx, IPU_PORT_ADDR) 
        ++p|          _exp(1, IPU_PORT_LC)
        ++p| 
        ++p|         :#rm_loop_col_low
        ++p|             _nop          
        ++p|             _sub(sx, 32)           
        ++p|             // sample and store in sw
        ++p|             _call(#_ipu_sw_sample_ana)
        ++p|             _nop
        ++p|             _exp(sx, IPU_PORT_ADDR)       
        ++p|             _add(su, sw) //Add to IPU accumulator
        ++p|             _addc(sz,0)        //Add carrys to second accumulator
        ++p|             _cmp(sx,234)
        ++p|         _jump(nz, :#rm_loop_col_low)
        ++p|         _nop
        ++p|         
        ++p|             
        ++p|         _add(sy, 32)
        ++p|     _jump(nz, :#rm_loop_row_low)
        ++p|     _nop
        ++p|     //sz has the 6 MSBs and sv the 8 LSBs so shift first byte left 2 positions, 2nd byte right 6 positions and OR together
        ++p|     //ignore the 6 LSBs
        ++p|         _shr(sv,sz)
        ++p|         _shr(sz,sv)
        ++p|         _shl(sv,su)
        ++p|         _shl(su,sv)
        ++p|         _shl(sv,su)
        ++p|         _shl(su,sv)
        ++p|         _shl(sv,su)
        ++p|         _shl(su,sv)
        ++p|         _or(sz,su)
        ++p|     _mov($r1,sz)
        ++p|    // clocks back to normal (9MHz at 90MHz clk)
        ++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        ++p|     _exp(0, IPU_PORT_RD)
        ++p| 
        ++p| !macro_end
        ++| 
        ++| 
        ++| //------------------------------------------------------------------------------
        ++| 
        ++| 
        ++p| !macro_def
        ++pg|     ipu.config_clocks
        ++pg| !macro_begin
        ++p|     _imp(su,3)
        ++p|     _exp(su,IPU_PORT_RISE_C1)
        ++p|     _imp(su,4)
        ++p|     _exp(su,IPU_PORT_FALL_C1)
        ++p|     _imp(su,5)
        ++p|     _exp(su,IPU_PORT_RISE_C2)
        ++p|     _imp(su,6)
        ++p|     _exp(su,IPU_PORT_FALL_C2)
        ++p|     _imp(su,7)
        ++p|     _exp(su,IPU_PORT_RISE_C3)
        ++p|     _imp(su,8)
        ++p|     _exp(su,IPU_PORT_FALL_C3)
        ++p|     _imp(su,9)
        ++p|     _exp(su,IPU_PORT_RISE_C4)
        ++p|     _imp(su,10)
        ++p|     _exp(su,IPU_PORT_FALL_C4)
        ++p| 
        ++p|     _imp(su,11)
        ++p|     _exp(su,IPU_PORT_FRAME_CNT_B0)
        ++p|     _imp(su,12)
        ++p|     _exp(su,IPU_PORT_FRAME_CNT_B1)
        ++p|     _imp(su,13)
        ++p|     _exp(su,IPU_PORT_FRAME_CNT_B2)
        ++p| !macro_end
        ++| 
        ++| 
        ++| // !macro_def
        ++| //     ipu.set_clock_boost
        ++| // !macro_begin
        ++| //     _exp(255, IPU_PORT_CLK_SWITCH)
        ++| //     _exp(1, IPU_PORT_RD)
        ++| // !macro_end
        ++| // 
        ++| // 
        ++| // 
        ++| // !macro_def
        ++| //     ipu.set_clock_normal
        ++| // !macro_begin
        ++| //     _exp(8, IPU_PORT_CLK_SWITCH)
        ++| //     _exp(0, IPU_PORT_RD)
        ++| // !macro_end
        ++| //
        ++| //
        ++| //
        ++| // !macro_def
        ++| //     ipu.apply_clock_dreg
        ++| // !macro_begin
        ++| //     _exp(4, IPU_PORT_CLK_SWITCH)
        ++| //     _nop
        ++| // !macro_end
        ++| 
        ++| 
        +| 
        +p| !include('scamp5c/scamp5c_io_macro.aps')
        ++| 
        ++p| !include('scamp5c/scamp5c_spi_macro.aps')
        +++| //
        +++| // IPU SPI Macros
        +++| //
        +++| // Aliased IPU registers:
        +++| // su -- s15
        +++| // sv -- s14
        +++| // sw -- s13
        +++| // sx -- s12
        +++| // sy -- s11
        +++| // sz -- s10
        +++| // 
        +++| // These macros assume the above ipu registers, R0, R1 and F to be volatile.
        +++| // 
        +++| //------------------------------------------------------------------------------
        +++| 
        +++| 
        +++p| !define(SPI_SIGNATURE_BYTE_0, 0x20)
        +++p| !define(SPI_SIGNATURE_BYTE_1, 0x16)
        +++p| !define(SPI_SIGNATURE_BYTE_2, 0xAA)
        +++| 
        +++p| !define(SPI_PACKET_TYPE_NO_PAYLOAD, 0)
        +++p| !define(SPI_PACKET_TYPE_CONST_SIZE, 1)
        +++p| !define(SPI_PACKET_TYPE_OPEN_SIZE, 2)
        +++p| !define(SPI_PACKET_TYPE_COMMAND, 3)
        +++p| !define(SPI_PACKET_TYPE_STANDARD_LOOPC, 4)
        +++p| !define(SPI_PACKET_TYPE_STANDARD_AOUT, 5)
        +++p| !define(SPI_PACKET_TYPE_STANDARD_DOUT, 6)
        +++p| !define(SPI_PACKET_TYPE_STANDARD_TARGET, 7)
        +++p| !define(SPI_PACKET_TYPE_STANDARD_EVENTS, 8)
        +++p| !define(SPI_PACKET_TYPE_STANDARD_APPINFO, 10)
        +++| 
        +++| 
        +++p| !define(SPI_FIFO_SPACE_128, 1)
        +++p| !define(SPI_FIFO_SPACE_256, 2)
        +++p| !define(SPI_FIFO_SPACE_384, 3)
        +++p| !define(SPI_FIFO_SPACE_512, 4)
        +++p| !define(SPI_FIFO_SPACE_640, 5)
        +++p| !define(SPI_FIFO_SPACE_768, 6)
        +++p| !define(SPI_FIFO_SPACE_896, 7)
        +++| 
        +++p| !define(SPI_RX_0, 160)
        +++p| !define(SPI_RX_1, 161)
        +++p| !define(SPI_RX_2, 162)
        +++p| !define(SPI_RX_3, 163)
        +++p| !define(SPI_RX_4, 164)
        +++p| !define(SPI_RX_5, 165)
        +++p| !define(SPI_RX_6, 166)
        +++p| !define(SPI_RX_7, 167)
        +++| 
        +++| 
        +++| // 
        +++p| !macro_def
        +++pg|     spi.reset
        +++pg| !macro_begin
        +++p|     _exp(4,253)
        +++p|     _exp(0,253)
        +++p| !macro_end
        +++| 
        +++| // 
        +++p| !macro_def
        +++pg|     spi.get_fifo_space($p)
        +++pg| !macro_begin
        +++p|     _imp($p,IPU_PORT_SPI_FIFO_SPACE)
        +++p| !macro_end
        +++| 
        +++| // 
        +++p| !macro_def
        +++pg|     spi.begin
        +++pg| !macro_begin
        +++p|     _exp(1, 253)
        +++p| !macro_end
        +++| 
        +++| // 
        +++p| !macro_def
        +++pg|     spi.end
        +++pg| !macro_begin
        +++p|     _exp(1, 246)
        +++p|     _exp(0, 246)
        +++p|     _nop
        +++p|     _exp(0, 253)
        +++p| !macro_end
        +++| 
        +++| // 
        +++p| !macro_def
        +++pg|     spi.data_ready
        +++pg| !macro_begin
        +++p|     _exp(1, 246)
        +++p|     _exp(0, 246)
        +++p| !macro_end
        +++| 
        +++| // 
        +++p| !macro_def
        +++pg|     spi.wait_fifo_space($e)
        +++pg| !macro_begin
        +++p|     _exp(1, 246)
        +++p|     _exp(0, 246)
        +++p|     :#wait_fifo_space
        +++p|     _nop
        +++p|     spi.get_fifo_space(su)
        +++p|     _sub(su,$e)
        +++p|     _jump(c,:#wait_fifo_space)
        +++p|     _nop
        +++p| !macro_end
        +++| 
        +++| // 
        +++p| !macro_def
        +++pg|     spi.wait_fifo
        +++pg| !macro_begin
        +++p|     :#wait_spi_fifo
        +++p|     _imp(su, IPU_PORT_SPI_USB_FLAGS)
        +++p|     _and(su, 4)
        +++p|     _jump(nz,:#wait_spi_fifo)
        +++p| !macro_end
        +++| 
        +++| // 
        +++p| !macro_def
        +++pg|     spi.send_byte($p1)
        +++pg| !macro_begin
        +++p|     _exp($p1,IPU_PORT_NO_IPU_DO)
        +++p| !macro_end
        +++| 
        +++| // 
        +++p| !macro_def
        +++pg|     $p = spi.port($e)
        +++pg| !macro_begin
        +++p|     _imp($p,$e)
        +++p| !macro_end
        +++| 
        +++| // 
        +++p| !macro_def
        +++pg|     spi.send_header_bytes($e,$p0,$p1,$p2)
        +++pg| !macro_begin
        +++p|     _mov(sv,$e)
        +++p|     _add(sv,$p0)
        +++p|     _add(sv,$p1)
        +++p|     _add(sv,$p2)
        +++p|     spi.send_byte(SPI_SIGNATURE_BYTE_0)
        +++p|     spi.send_byte(SPI_SIGNATURE_BYTE_1)
        +++p|     spi.send_byte(SPI_SIGNATURE_BYTE_2)
        +++p|     spi.send_byte($e)// packet type
        +++p|     spi.send_byte($p0)// payload size
        +++p|     spi.send_byte($p1)
        +++p|     spi.send_byte($p2)
        +++p|     spi.send_byte(sv)// header checksum
        +++p| !macro_end
        +++| 
        +++| // 
        +++p| !macro_def
        +++pg|     spi.send_header($p0)
        +++pg| !macro_begin
        +++p|     spi.send_header_bytes(SPI_PACKET_TYPE_CONST_SIZE,$p0,0,0)
        +++p| !macro_end
        +++| 
        +++| // 
        +++p| !macro_def
        +++pg|     spi.send_header($p0,$p1)
        +++pg| !macro_begin
        +++p|     spi.send_header_bytes(SPI_PACKET_TYPE_CONST_SIZE,$p0,$p1,0)
        +++p| !macro_end
        +++| 
        +++| 
        +++| //------------------------------------------------------------------------------
        +++| 
        +++| 
        +++p| !macro_def
        +++pg|     spi.set_transfer_size($p0,$p1)
        +++pg| !macro_begin
        +++p|     
        +++p|     _exp(255, IPU_PORT_CLK_SWITCH)
        +++p|     _nop
        +++p|     
        +++p|     spi.begin
        +++p|     spi.send_header_bytes(SPI_PACKET_TYPE_COMMAND,0x02,$p0,$p1)
        +++p|     spi.end
        +++p|     
        +++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        +++p|     _nop
        +++p|     
        +++p| !macro_end
        +++| 
        +++| 
        +++p| !macro_def
        +++pg|     spi.set_transfer_size($p0)
        +++pg| !macro_begin
        +++p|     spi.set_transfer_size($p0,0)
        +++p| !macro_end
        +++| 
        +++| 
        +++| //------------------------------------------------------------------------------
        +++| 
        +++| 
        +++p| !macro_def
        +++pg|     spi.send_loop_counter
        +++pg| !macro_begin
        +++p|     
        +++p|     _exp(255, IPU_PORT_CLK_SWITCH)
        +++p|     _nop
        +++p|     
        +++p|     // spi header
        +++p|     spi.send_byte(SPI_SIGNATURE_BYTE_0)
        +++p|     spi.send_byte(SPI_SIGNATURE_BYTE_1)
        +++p|     spi.send_byte(SPI_SIGNATURE_BYTE_2)
        +++p|     spi.send_byte(SPI_PACKET_TYPE_STANDARD_LOOPC)// 4
        +++p|     spi.send_byte(4)// payload size
        +++p|     spi.send_byte(0)
        +++p|     spi.send_byte(0)
        +++p|     spi.send_byte(8)// header checksum
        +++p|     
        +++p|     // uint32 payload: loop counter
        +++p|     _imp(sv,IPU_PORT_LOOPC_0)
        +++p|     spi.send_byte(sv)
        +++p|     _imp(sv,IPU_PORT_LOOPC_1)
        +++p|     spi.send_byte(sv)
        +++p|     _imp(sv,IPU_PORT_LOOPC_2)
        +++p|     spi.send_byte(sv)
        +++p|     _imp(sv,IPU_PORT_LOOPC_3)
        +++p|     spi.send_byte(sv)
        +++p|     
        +++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        +++p|     _nop
        +++p|     
        +++p| !macro_end
        +++| 
        +++| 
        +++| //------------------------------------------------------------------------------
        +++| 
        +++| 
        +++p| !macro_def
        +++pg|     spi.aout($r1)
        +++pg| !macro_begin
        +++p| 
        +++p|     _exp(2, IPU_PORT_ADC_FEAMP)
        +++p|     keep
        +++p|     set_sel_ana($r1)
        +++p|     _nop
        +++p|     
        +++p|     _exp(255, IPU_PORT_CLK_SWITCH)
        +++p|     _nop
        +++p|     _exp(7, IPU_PORT_ADC_FEAMP)
        +++p|     
        +++p|     // spi header
        +++p|     spi.send_byte(SPI_SIGNATURE_BYTE_0)
        +++p|     spi.send_byte(SPI_SIGNATURE_BYTE_1)
        +++p|     spi.send_byte(SPI_SIGNATURE_BYTE_2)
        +++p|     spi.send_byte(SPI_PACKET_TYPE_STANDARD_AOUT)// 5
        +++p|     spi.send_byte(0x08)// payload size
        +++p|     spi.send_byte(0x00)
        +++p|     spi.send_byte(0x01)
        +++p|     spi.send_byte(0x0E)// header checksum
        +++p|     
        +++p|     // uint32 payload: loop counter
        +++p|     _imp(sv,IPU_PORT_LOOPC_0)
        +++p|     spi.send_byte(sv)
        +++p|     _imp(sv,IPU_PORT_LOOPC_1)
        +++p|     spi.send_byte(sv)
        +++p|     _imp(sv,IPU_PORT_LOOPC_2)
        +++p|     spi.send_byte(sv)
        +++p|     _imp(sv,IPU_PORT_LOOPC_3)
        +++p|     spi.send_byte(sv)
        +++p|     
        +++p|     // uint16: width 
        +++p|     spi.send_byte(0x00)
        +++p|     spi.send_byte(0x01)
        +++p|     
        +++p|     // uint16: height
        +++p|     spi.send_byte(0x00)
        +++p|     spi.send_byte(0x01)
        +++p| 
        +++p|     _exp(1, 246)
        +++p|     _exp(0, 246)
        +++p|     _nop
        +++p|     
        +++p|     _mov(sv,1)
        +++p|     _call(#_ipu_sa_readout_rm_spi)
        +++p|     _nop
        +++p|     
        +++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        +++p|     _exp(0, IPU_PORT_RD)
        +++p|     _nop
        +++p|     
        +++p| !macro_end
        +++| 
        +++| 
        +++| //------------------------------------------------------------------------------
        +++| 
        +++| 
        +++p| !macro_def
        +++pg|     spi.aout64($r1)
        +++pg| !macro_begin
        +++p| 
        +++p|     _exp(2, IPU_PORT_ADC_FEAMP)
        +++p|     keep
        +++p|     set_sel_ana($r1)
        +++p|     _nop
        +++p|     
        +++p|     _exp(255, IPU_PORT_CLK_SWITCH)
        +++p|     _nop
        +++p|     _exp(7, IPU_PORT_ADC_FEAMP)
        +++p|     
        +++p|     // spi header
        +++p|     spi.send_byte(SPI_SIGNATURE_BYTE_0)
        +++p|     spi.send_byte(SPI_SIGNATURE_BYTE_1)
        +++p|     spi.send_byte(SPI_SIGNATURE_BYTE_2)
        +++p|     spi.send_byte(SPI_PACKET_TYPE_STANDARD_AOUT)// 5
        +++p|     spi.send_byte(0x08)// payload size
        +++p|     spi.send_byte(0x10)
        +++p|     spi.send_byte(0x00)
        +++p|     spi.send_byte(0x1D)// header checksum
        +++p|     
        +++p|     // uint32: loop counter
        +++p|     _imp(sv,IPU_PORT_LOOPC_0)
        +++p|     spi.send_byte(sv)
        +++p|     _imp(sv,IPU_PORT_LOOPC_1)
        +++p|     spi.send_byte(sv)
        +++p|     _imp(sv,IPU_PORT_LOOPC_2)
        +++p|     spi.send_byte(sv)
        +++p|     _imp(sv,IPU_PORT_LOOPC_3)
        +++p|     spi.send_byte(sv)
        +++p|     
        +++p|     // uint16: width 
        +++p|     spi.send_byte(0x40)
        +++p|     spi.send_byte(0x00)
        +++p|     
        +++p|     // uint16: height
        +++p|     spi.send_byte(0x40)
        +++p|     spi.send_byte(0x00)
        +++p|     
        +++p|     _exp(1, 246)
        +++p|     _exp(0, 246)
        +++p|     _nop
        +++p|     
        +++p|     _mov(sv,4)
        +++p|     _call(#_ipu_sa_readout_rm_spi)
        +++p|     _nop
        +++p|     
        +++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        +++p|     _exp(0, IPU_PORT_RD)
        +++p|     _nop
        +++p|     
        +++p| !macro_end
        +++| 
        +++| 
        +++| //------------------------------------------------------------------------------
        +++| 
        +++| 
        +++p| !macro_def
        +++pg|     spi.dout($r1)
        +++pg| !macro_begin
        +++p|     _exp(6,IPU_PORT_FALL_C1) //THESE CLOCK CHANGES are here since THE critical item appears to be WHERE rather than the rest of the readout algo
        +++p|     _exp(7,IPU_PORT_RISE_C2) 
        +++p|     _exp(9,IPU_PORT_FALL_C2) 
        +++p|     
        +++p| 
        +++p|     all
        +++p|     where($r1)
        +++p|     
        +++p|   //  _exp(255, IPU_PORT_CLK_SWITCH)
        +++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        +++p|     _nop
        +++p|     
        +++p|     _exp(0, IPU_PORT_B)
        +++p|     keep
        +++p|     set('pgdb' 'dig8' 'pgdbobus' 'sin') //get the command required sent whenever I turn clocks on
        +++p|     
        +++p|     _exp(255, IPU_PORT_CLK_SWITCH)
        +++p|     //_nop
        +++p|     _exp(0, IPU_PORT_RD) //turn on clocks
        +++p|     
        +++p|     // spi header
        +++p|     spi.send_byte(SPI_SIGNATURE_BYTE_0)
        +++p|     spi.send_byte(SPI_SIGNATURE_BYTE_1)
        +++p|     spi.send_byte(SPI_SIGNATURE_BYTE_2)
        +++p|     spi.send_byte(SPI_PACKET_TYPE_STANDARD_DOUT)// 6
        +++p|     spi.send_byte(0x08)// payload size
        +++p|     spi.send_byte(0x20)
        +++p|     spi.send_byte(0x00)
        +++p|     spi.send_byte(0x2E)// header checksum
        +++p|     
        +++p|     // uint32 payload: loop counter
        +++p|     _imp(sv,IPU_PORT_LOOPC_0)
        +++p|     spi.send_byte(sv)
        +++p|     _imp(sv,IPU_PORT_LOOPC_1)
        +++p|     spi.send_byte(sv)
        +++p|     _imp(sv,IPU_PORT_LOOPC_2)
        +++p|     spi.send_byte(sv)
        +++p|     _imp(sv,IPU_PORT_LOOPC_3)
        +++p|     spi.send_byte(sv)
        +++p|     
        +++p|     // uint16: width 
        +++p|     spi.send_byte(0x00)
        +++p|     spi.send_byte(0x01)
        +++p|     
        +++p|     // uint16: height
        +++p|     spi.send_byte(0x00)
        +++p|     spi.send_byte(0x01)
        +++p| 
        +++p|     _exp(1, 246)
        +++p|     _exp(0, 246)
        +++p|     _nop
        +++p|     
        +++p|     _call(#_ipu_spi_dout)
        +++p|     _nop
        +++p|     
        +++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        +++p|     _exp(4,IPU_PORT_FALL_C1)
        +++p|     _exp(5,IPU_PORT_RISE_C2) 
        +++p|     _exp(9,IPU_PORT_FALL_C2) 
        +++p|     _exp(0, IPU_PORT_RD)
        +++p|     _nop
        +++p|     
        +++p| !macro_end
        +++| 
        +++| 
        +++| //------------------------------------------------------------------------------
        +++| 
        +++| 
        +++p| !macro_def
        +++pg|     spi.scan_events($r1,$p0)
        +++pg| !macro_begin
        +++p|     spi.scan_events($r1,$p0,0)
        +++p| !macro_end
        +++| 
        +++| 
        +++| 
        +++p| !macro_def
        +++pg|     spi.scan_events($r1,$p0,$p1)
        +++pg| !macro_begin
        +++p| 
        +++p|     _exp(255, IPU_PORT_CLK_SWITCH)
        +++p|     _nop
        +++p|     _exp(1, IPU_PORT_RD)
        +++p|     _nop
        +++p|     
        +++p|     // calculate payload size
        +++p| //     make_load_uint16($i,sv,sw)
        +++p|     _mov(sv,$p0)
        +++p|     _mov(sw,$p1)
        +++p|     _add(sv,$p0)
        +++p|     _addc(sw,$p1)
        +++p|     _add(sv,8)// loop counter + coords count
        +++p|     _addc(sw,0)
        +++p|     
        +++p|     // calculate checksum
        +++p|     _mov(sz,SPI_PACKET_TYPE_STANDARD_EVENTS)
        +++p|     _add(sz,sv)
        +++p|     _add(sz,sw)
        +++p|     
        +++p|     // spi header
        +++p|     spi.send_byte(SPI_SIGNATURE_BYTE_0)
        +++p|     spi.send_byte(SPI_SIGNATURE_BYTE_1)
        +++p|     spi.send_byte(SPI_SIGNATURE_BYTE_2)
        +++p|     spi.send_byte(SPI_PACKET_TYPE_STANDARD_EVENTS)
        +++p|     spi.send_byte(sv)// payload size
        +++p|     spi.send_byte(sw)
        +++p|     spi.send_byte(0)
        +++p|     spi.send_byte(sz)// header checksum
        +++p|     
        +++p|     // uint32: loop counter
        +++p|     _imp(sv,IPU_PORT_LOOPC_0)
        +++p|     spi.send_byte(sv)
        +++p|     _imp(sv,IPU_PORT_LOOPC_1)
        +++p|     spi.send_byte(sv)
        +++p|     _imp(sv,IPU_PORT_LOOPC_2)
        +++p|     spi.send_byte(sv)
        +++p|     _imp(sv,IPU_PORT_LOOPC_3)
        +++p|     spi.send_byte(sv)
        +++p|     
        +++p|     // uint16: event dimension
        +++p|     spi.send_byte(0x02)
        +++p|     spi.send_byte(0x00)
        +++p|     
        +++p|     // uint16: event count
        +++p|     spi.send_byte($p0)
        +++p|     spi.send_byte($p1)
        +++p|     
        +++p|     // do the scanning
        +++p|     
        +++p|     _exp(255, IPU_PORT_ADDR) //search all rows
        +++p|     _exp(1, IPU_PORT_LRX)
        +++p|     _exp(0, IPU_PORT_LRX)
        +++p|     _exp(0, IPU_PORT_ADDR) 
        +++p|     _exp(1, IPU_PORT_LCX)
        +++p|     _exp(0, IPU_PORT_LCX)
        +++p|     _exp(1, IPU_PORT_LC) //leave latch up on col
        +++p|     _exp(0, IPU_PORT_LC)
        +++p|     
        +++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        +++p|     _nop
        +++p|     _exp(0, IPU_PORT_RD)
        +++p|     _nop
        +++p|     nop
        +++p|     nop
        +++p|     nop
        +++p|     nop
        +++p|     _exp(4, IPU_PORT_CLK_SWITCH) //returns clocks back to normal (9MHz at 90MHz clk)
        +++p|     _nop
        +++p|     
        +++p|     R0 = $r1
        +++p|     R3 = 0
        +++p|     
        +++p|     //
        +++p| //     make_load_uint16($i,sv,sw)
        +++p|     _mov(sw,$p1)
        +++p|     _mov(sv,$p0)
        +++p|     :#scanning_loop_begin
        +++p|         _nop
        +++p|         _sub(sv,1)
        +++p|         _subc(sw,0)
        +++p|         _jump(c,:#scanning_loop_end)
        +++p|         _nop
        +++p|     
        +++p|         //Remove a pixel that has already been output (none on first run)
        +++p|         set('LR4' 'nbit' 'plrb' 'rfl' ) //R4 = not(R0)
        +++p|         set('lfl' 'RR4' 'RR3' 'nbit' 'plrb' )//R0 = not( R4 OR R3)
        +++p|         
        +++p|         R2 = $r1
        +++p|         $r1 = R2
        +++p|         
        +++p|         all
        +++p|         where(R0)
        +++p|         
        +++p|         _exp(2,IPU_PORT_FALL_C1)
        +++p|         _exp(7,IPU_PORT_RISE_C2) //make this a count of 2 if running at 180MHz
        +++p|         _exp(8,IPU_PORT_FALL_C2)    
        +++p|         
        +++p|         _exp(4, IPU_PORT_CLK_SWITCH)
        +++p|         _nop
        +++p|         
        +++p|         set( 'pgdb' 'pgdbobus' 'col_out' ) //output first live column (all rows active)
        +++p|         keep
        +++p|         set( 'col_out' )  
        +++p|         _imp(sx,234) //Get data from Dig port
        +++p|         
        +++p|         _exp(4,IPU_PORT_CLK_SWITCH) // dreg operation clock
        +++p|         _nop
        +++p|         R2 = $r1
        +++p|         $r1 = R2
        +++p|         
        +++p|         _exp(sx, IPU_PORT_ADDR) //Specifies which column searched (that is, the column just found above). 
        +++p|         _exp(1, IPU_PORT_LC)
        +++p|         _exp(0, IPU_PORT_LC)
        +++p|         
        +++p|         set( 'pgdb' 'row_out' )
        +++p|         keep
        +++p|         set( 'row_out' )
        +++p|         _imp(sy,234)//Now have row coord of pixel found in column y=s3 x=s5
        +++p|         
        +++p|          //send coordinates
        +++p|         _mov(su,255)
        +++p|         _sub(su,sx)
        +++p|         spi.send_byte(su)
        +++p|         spi.send_byte(sy)
        +++p| 
        +++p|         
        +++p|         //remove the pixel just found from image
        +++p|         _exp(sy, IPU_PORT_ADDR)
        +++p|         _exp(1, IPU_PORT_LR)
        +++p|         _exp(0, IPU_PORT_LR)
        +++p|         _exp(0, IPU_PORT_ADDR) //Just specify one row
        +++p|         _exp(1, IPU_PORT_LRX)
        +++p|         _exp(0, IPU_PORT_LRX)
        +++p|         
        +++p|         _exp(4, IPU_PORT_CLK_SWITCH) // dreg operation clock
        +++p|         _nop
        +++p|         set('LR3' 'wr' 'bitmode' 'bit' 'plrb' )
        +++p|         
        +++p|         //search all rows again to look for next pixel
        +++p|         _exp(255, IPU_PORT_ADDR) 
        +++p|         _exp(1, IPU_PORT_LRX)
        +++p|         _exp(0, IPU_PORT_LRX)
        +++p|         
        +++p|         _jump(:#scanning_loop_begin)
        +++p|         _nop
        +++p|     :#scanning_loop_end
        +++p|     _nop
        +++p|     
        +++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        +++p|     _nop
        +++p|     _exp(1,IPU_PORT_FALL_C1)
        +++p|     _exp(5,IPU_PORT_FALL_C1)
        +++p|     _exp(6,IPU_PORT_RISE_C2) //make this a count of 2 if running at 180MHz
        +++p|     _exp(9,IPU_PORT_FALL_C2)
        +++p|     
        +++p|     all
        +++p|     
        +++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        +++p|     _nop
        +++p|     
        +++p| !macro_end
        +++| 
        +++| 
        +++| //------------------------------------------------------------------------------
        +++| 
        +++| 
        +++p| !macro_def
        +++pg|     spi.scan_target($r1)
        +++pg| !macro_begin
        +++p|     
        +++p|     
        +++p|     _exp(255, IPU_PORT_CLK_SWITCH)
        +++p|     _exp(1, IPU_PORT_RD)
        +++p|     
        +++p|     // spi header
        +++p|     spi.send_byte(SPI_SIGNATURE_BYTE_0)
        +++p|     spi.send_byte(SPI_SIGNATURE_BYTE_1)
        +++p|     spi.send_byte(SPI_SIGNATURE_BYTE_2)
        +++p|     spi.send_byte(SPI_PACKET_TYPE_STANDARD_TARGET)// 7
        +++p|     spi.send_byte(8)// payload size
        +++p|     spi.send_byte(0)
        +++p|     spi.send_byte(0)
        +++p|     spi.send_byte(15)// header checksum
        +++p|     
        +++p|     // uint32 payload: loop counter
        +++p|     _imp(sv,IPU_PORT_LOOPC_0)
        +++p|     spi.send_byte(sv)
        +++p|     _imp(sv,IPU_PORT_LOOPC_1)
        +++p|     spi.send_byte(sv)
        +++p|     _imp(sv,IPU_PORT_LOOPC_2)
        +++p|     spi.send_byte(sv)
        +++p|     _imp(sv,IPU_PORT_LOOPC_3)
        +++p|     spi.send_byte(sv)
        +++p|     
        +++p|     // do the scanning
        +++p|     
        +++p|     _exp(255, IPU_PORT_ADDR) //search all rows
        +++p|     _exp(1, IPU_PORT_LRX)
        +++p|     _exp(0, IPU_PORT_LRX)
        +++p|     _exp(255, IPU_PORT_ADDR) //search all col
        +++p|     _exp(1, IPU_PORT_LCX)
        +++p|     _exp(0, IPU_PORT_LCX)
        +++p|     
        +++p|     _exp(0, IPU_PORT_ADDR)
        +++p|     _exp(1, IPU_PORT_LC)
        +++p|     _exp(0, IPU_PORT_LC)
        +++p|     _exp(1, IPU_PORT_LR)
        +++p|     _exp(0, IPU_PORT_LR)
        +++p|     
        +++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        +++p|     _nop
        +++p|     _exp(0, IPU_PORT_RD)
        +++p|     _nop
        +++p|     R0 = $r1
        +++p|     $r1 = R0
        +++p|     nop
        +++p|     nop
        +++p|     nop
        +++p|     nop
        +++p|     _exp(4, IPU_PORT_CLK_SWITCH) //returns clocks back to normal (9MHz at 90MHz clk)
        +++p|     _nop
        +++p|     
        +++p|     all
        +++p|     where($r1)
        +++p|     
        +++p|     _exp(2,IPU_PORT_FALL_C1)
        +++p|     _exp(7,IPU_PORT_RISE_C2) //make this a count of 2 if running at 180MHz
        +++p|     _exp(8,IPU_PORT_FALL_C2)    
        +++p|     
        +++p|     _exp(4, IPU_PORT_CLK_SWITCH)
        +++p|     _nop
        +++p|     
        +++p|     set( 'pgdb' 'pgdbobus' 'col_out' 'dir' ) //output first live column (all rows active)
        +++p|     keep
        +++p|     set( 'col_out' 'dir' )
        +++p|     _imp(sx,234) //Get data from Dig port
        +++p|     
        +++p|     _exp(4,IPU_PORT_CLK_SWITCH) // dreg operation clock
        +++p|     _nop
        +++p|     
        +++p|     
        +++p|     set( 'pgdb' 'row_out' )
        +++p|     keep
        +++p|     set( 'row_out' )
        +++p|     _imp(sy,234)//Now have row coord of pixel found in column y=s3 x=s5
        +++p|     
        +++p|      //send coordinates
        +++p|     _mov(su,255)
        +++p|     _sub(su,sx)
        +++p|     spi.send_byte(su)
        +++p|     spi.send_byte(sy)
        +++p| 
        +++p|     
        +++p|     _exp(2,IPU_PORT_FALL_C1)
        +++p|     _exp(7,IPU_PORT_RISE_C2) //make this a count of 2 if running at 180MHz
        +++p|     _exp(8,IPU_PORT_FALL_C2)    
        +++p|     
        +++p|     _exp(4, IPU_PORT_CLK_SWITCH)
        +++p|     _nop
        +++p|     
        +++p|     set( 'pgdb' 'pgdbobus' 'col_out' ) //output last live column (all rows active)
        +++p|     keep
        +++p|     set( 'col_out' )  
        +++p|     _imp(sx,234) //Get data from Dig port
        +++p|     
        +++p|     _exp(4,IPU_PORT_CLK_SWITCH) // dreg operation clock
        +++p|     _nop
        +++p|     
        +++p|     
        +++p|     set( 'pgdb' 'row_out' 'dir' )
        +++p|     keep
        +++p|     set( 'row_out' 'dir' )
        +++p|     _imp(sy,234)//Now have row coord of pixel found in column y=s3 x=s5
        +++p|     
        +++p|      //send coordinates
        +++p|     _mov(su,255)
        +++p|     _sub(su,sx)
        +++p|     spi.send_byte(su)
        +++p|     spi.send_byte(sy)
        +++p|     
        +++p|     
        +++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        +++p|     _nop
        +++p|     _exp(1,IPU_PORT_FALL_C1)
        +++p|     _exp(5,IPU_PORT_FALL_C1)
        +++p|     _exp(6,IPU_PORT_RISE_C2) //make this a count of 2 if running at 180MHz
        +++p|     _exp(9,IPU_PORT_FALL_C2)
        +++p|     
        +++p|     all
        +++p|     
        +++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        +++p|     _nop
        +++p|     
        +++p| !macro_end
        +++| 
        ++p| !include('scamp5c/scamp5c_usb_macro.aps')
        +++| //
        +++| // IPU IO Macros
        +++| //
        +++| // Aliased IPU registers:
        +++| // su -- s15
        +++| // sv -- s14
        +++| // sw -- s13
        +++| // sx -- s12
        +++| // sy -- s11
        +++| // sz -- s10
        +++| // 
        +++| // These macros assume the above ipu registers, R0, R1 and F to be volatile.
        +++| // 
        +++| //------------------------------------------------------------------------------
        +++| 
        +++p| !macro_def
        +++pg|     $p1 = usb.slider($p2)
        +++pg| !macro_begin
        +++p|     su = host_slider($p2)
        +++p|     _mov($p1,su)
        +++p|     _cmp($p1,0)
        +++p| !macro_end
        +++| 
        +++| 
        +++p| !macro_def
        +++pg|     usb.wait_fifo
        +++pg| !macro_begin
        +++p|     :#wait_usb_fifo
        +++p|     _imp(su, IPU_PORT_NO_USB_FLAGS)
        +++p|     _and(su, 1)
        +++p|     _jump(nz,:#wait_usb_fifo)
        +++p| !macro_end
        +++| 
        +++| 
        +++p| !macro_def
        +++pg|     usb.send_byte($p1)
        +++pg| !macro_begin
        +++p|     usb.wait_fifo
        +++p|     _exp($p1,IPU_PORT_NO_IPU_DO)
        +++p| !macro_end
        +++| 
        +++| 
        +++p| !macro_def
        +++pg|     usb.aout($r1,$h)
        +++pg| !macro_begin
        +++p|     host_aout($h)
        +++p|     _exp(2, IPU_PORT_ADC_FEAMP)
        +++p|     keep
        +++p|     set_sel_ana($r1)
        +++p|     !endif
        +++p|     !if(USE_CALL_USB_AOUT_256_ROW_MAJOR, ==, 1)
        +++p|     _call(#_ipu_sa_readout_256_rm)
        +++p|     _nop
        +++p|     !endif
        +++p| !macro_end
        +++| 
        +++| 
        +++p| !macro_def
        +++pg|     usb.d2aout($r1,$h)
        +++pg| !macro_begin
        +++p|     all
        +++p|     set('plrb' 'rid' ) //this drives the bus to zero volts
        +++p|     _exp(0, IPU_PORT_B)
        +++p|     F = IN
        +++p|     where($r1)
        +++p|         set('plrb' 'rid' ) //this drives the bus to zero volts
        +++p|         _exp(255, IPU_PORT_B)
        +++p|         F = IN
        +++p|     all
        +++p|     _nop
        +++p|     host_aout($h)
        +++p|     _exp(2, IPU_PORT_ADC_FEAMP)
        +++p|     keep
        +++p|     set_sel_ana(F)
        +++p|     !endif
        +++p|     !if(USE_CALL_USB_AOUT_256_ROW_MAJOR, ==, 1)
        +++p|     _call(#_ipu_sa_readout_256_rm)
        +++p|     _nop
        +++p|     !endif
        +++p| !macro_end
        +++| 
        +++| 
        +++| 
        +++p| !macro_def
        +++pg|     usb.dout($r1,$h)
        +++pg| !macro_begin
        +++p|     host_dout($h)
        +++p|     all
        +++p|     _exp(6,IPU_PORT_FALL_C1) //THESE CLOCK CHANGES are here since THE critical item appears to be WHERE rather than the rest of the readout algo
        +++p|     _exp(7,IPU_PORT_RISE_C2) 
        +++p|     _exp(9,IPU_PORT_FALL_C2) 
        +++p|     _nop 
        +++p|     where($r1)
        +++p|     _call(#_ipu_sa_dout_usb)
        +++p|     _nop
        +++p|     _exp(4,IPU_PORT_FALL_C1)
        +++p|     _exp(5,IPU_PORT_RISE_C2) 
        +++p|     _exp(9,IPU_PORT_FALL_C2) 
        +++p| !macro_end
        +++| 
        +++| 
        +++| 
        +++p| !macro_def
        +++pg|     usb.stream_begin($h)
        +++pg| !macro_begin
        +++p|     host_xout($h)
        +++p|     usb.send_byte(PCKT_START)
        +++p|     usb.send_byte(13) // 7 for x, 8 for y, 13 for a stream of bytes
        +++p|     usb.send_byte(0)
        +++p|     usb.send_byte(0)
        +++p|     usb.send_byte(0)
        +++p|     usb.send_byte(0)
        +++p| !macro_end
        +++| 
        +++| 
        +++| 
        +++p| !macro_def
        +++pg|     usb.stream_send($p1)
        +++pg| !macro_begin
        +++p|     usb.send_byte($p1)
        +++p| !macro_end
        +++| 
        +++| 
        +++| 
        +++p| !macro_def
        +++pg|     usb.stream_end
        +++pg| !macro_begin
        +++p|     _nop
        +++p| !macro_end
        +++| 
        +++| 
        +++| 
        +++p| !macro_def
        +++pg|     usb.stream_end($p1,$p2)
        +++pg| !macro_begin
        +++p|     _mov(sz,$p1)
        +++p|     _cmp(sz,0)
        +++p|     _jump(z,:#no_padding_bytes)
        +++p|     :#padding_bytes
        +++p|     usb.send_byte($p2)
        +++p|     _sub(sz,1)
        +++p|     _jump(nz,:#padding_bytes)
        +++p|     :#no_padding_bytes
        +++p|     _nop
        +++p| !macro_end
        +++| 
        +++| 
        +++| 
        +++p| !macro_def
        +++pg|     usb.scan_events($h,$r1,$p0)
        +++pg| !macro_begin
        +++p|     usb.scan_events($h,$r1,$p0,0)
        +++p| !macro_end
        +++| 
        +++| 
        +++| 
        +++p| !macro_def
        +++pg|     usb.scan_events($h,$r1,$p0,$p1)
        +++pg| !macro_begin
        +++p|     host_xout($h)
        +++p|     
        +++p|     _exp(255, IPU_PORT_CLK_SWITCH)
        +++p|     _nop
        +++p|     _exp(1, IPU_PORT_RD)
        +++p|     _nop
        +++p|     
        +++p|     usb.send_byte(PCKT_START)
        +++p|     usb.send_byte(13) // 7 for x, 8 for y, 13 for a stream of bytes
        +++p|     usb.send_byte(0)
        +++p|     usb.send_byte(0)
        +++p|     usb.send_byte(0)
        +++p|     usb.send_byte(0)
        +++p|     _nop
        +++p|     
        +++p|     // scanning
        +++p|     
        +++p|     _exp(255, IPU_PORT_ADDR) //search all rows
        +++p|     _exp(1, IPU_PORT_LRX)
        +++p|     _exp(0, IPU_PORT_LRX)
        +++p|     _exp(0, IPU_PORT_ADDR) 
        +++p|     _exp(1, IPU_PORT_LCX)
        +++p|     _exp(0, IPU_PORT_LCX)
        +++p|     _exp(1, IPU_PORT_LC) //leave latch up on col
        +++p|     _exp(0, IPU_PORT_LC)
        +++p|     
        +++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        +++p|     _nop
        +++p|     _exp(0, IPU_PORT_RD)
        +++p|     _nop
        +++p|     nop
        +++p|     nop
        +++p|     nop
        +++p|     nop
        +++p|     _exp(4, IPU_PORT_CLK_SWITCH) //returns clocks back to normal (9MHz at 90MHz clk)
        +++p|     _nop
        +++p|     
        +++p|     R0 = $r1
        +++p|     R3 = 0
        +++p|     
        +++p| //     make_load_uint16($i,sv,sw)
        +++p|     _mov(sw,$p1)
        +++p|     _mov(sv,$p0)
        +++p|     :#scanning_loop_begin
        +++p|         _nop
        +++p|         _sub(sv,1)
        +++p|         _subc(sw,0)
        +++p|         _jump(c,:#scanning_loop_end)
        +++p|         _nop
        +++p|         
        +++p|         //Remove a pixel that has already been output (none on first run)
        +++p|         set('LR4' 'nbit' 'plrb' 'rfl' ) //R7 = not(R5)
        +++p|         set('lfl' 'RR4' 'RR3' 'nbit' 'plrb' )//R5 = not( R4 OR R3)
        +++p|         
        +++p|         R2 = $r1
        +++p|         $r1 = R2
        +++p|         
        +++p|         all
        +++p|         where(R0)
        +++p|         
        +++p|         _exp(2,IPU_PORT_FALL_C1)
        +++p|         _exp(7,IPU_PORT_RISE_C2) //make this a count of 2 if running at 180MHz
        +++p|         _exp(8,IPU_PORT_FALL_C2)    
        +++p|         
        +++p|         _exp(4, IPU_PORT_CLK_SWITCH)
        +++p|         _nop
        +++p|         
        +++p|         set( 'pgdb' 'pgdbobus' 'col_out' ) //output first live column (all rows active)
        +++p|         keep
        +++p|         set( 'col_out' )  
        +++p|         _imp(sx,234) //Get data from Dig port
        +++p|         
        +++p|         _exp(4,IPU_PORT_CLK_SWITCH) // dreg operation clock
        +++p|         _nop
        +++p|         R2 = $r1
        +++p|         $r1 = R2
        +++p|         
        +++p|         _exp(sx, IPU_PORT_ADDR) //Specifies which column searched (that is, the column just found above). 
        +++p|         _exp(1, IPU_PORT_LC)
        +++p|         _exp(0, IPU_PORT_LC)
        +++p|         
        +++p|         set( 'pgdb' 'row_out' )
        +++p|         keep
        +++p|         set( 'row_out' )
        +++p|         _imp(sy,234)//Now have row coord of pixel found in column y=s3 x=s5
        +++p|         
        +++p|          //send coordinate to USB
        +++p|         _mov(sz,255)
        +++p|         _sub(sz,sx)
        +++p|         
        +++p|         usb.send_byte(sz)
        +++p|         usb.send_byte(sy)
        +++p|         
        +++p|         //remove the pixel just found from image
        +++p|         _exp(sy, IPU_PORT_ADDR)
        +++p|         _exp(1, IPU_PORT_LR)
        +++p|         _exp(0, IPU_PORT_LR)
        +++p|         _exp(0, IPU_PORT_ADDR) //Just specify one row
        +++p|         _exp(1, IPU_PORT_LRX)
        +++p|         _exp(0, IPU_PORT_LRX)
        +++p|         
        +++p|         _exp(4, IPU_PORT_CLK_SWITCH) // dreg operation clock
        +++p|         _nop
        +++p|         set('LR3' 'wr' 'bitmode' 'bit' 'plrb'  )
        +++p|         
        +++p|         //search all rows again to look for next pixel
        +++p|         _exp(255, IPU_PORT_ADDR) 
        +++p|         _exp(1, IPU_PORT_LRX)
        +++p|         _exp(0, IPU_PORT_LRX)
        +++p|         
        +++p|         _jump(:#scanning_loop_begin)
        +++p|         _nop
        +++p|     :#scanning_loop_end
        +++p|     _nop
        +++p| 
        +++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        +++p|     _nop
        +++p|     _exp(1,IPU_PORT_FALL_C1)
        +++p|     _exp(5,IPU_PORT_FALL_C1)
        +++p|     _exp(6,IPU_PORT_RISE_C2) //make this a count of 2 if running at 180MHz
        +++p|     _exp(9,IPU_PORT_FALL_C2)
        +++p|     
        +++p|     all
        +++p|     
        +++p|     _nop
        +++p|     _nop
        +++p|     _nop
        +++p|     _nop
        +++p|     
        +++p| !macro_end
        +++| 
        ++| 
        +p| !include('scamp5c/scamp5c_pro_macro.aps')
        ++| 
        ++| //      R1 = 1// south (shift north)
        ++| //      R2 = 0// west (shift east)
        ++| //      R3 = 0// north
        ++| //      R4 = 0// east
        ++p| !macro_def
        ++pg|     $ret = pro.digital_news($r1,$str)
        ++pg| !macro_begin
        ++p|     _exp(4,IPU_PORT_CLK_SWITCH)
        ++p|     _exp(6,IPU_PORT_RISE_C2)
        ++p|     _exp(7,IPU_PORT_FALL_C2)
        ++p|     
        ++p|         
        ++p|     R1 R2 R3 R4 = 0
        ++p|     resolve_dnews($str)
        ++p|     
        ++p|     R0 = dnews($r1)
        ++p|     $ret = R0
        ++p|     
        ++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        ++p|     _nop
        ++p|     _exp(4,IPU_PORT_FALL_C1)
        ++p|     _exp(4,IPU_PORT_RISE_C2)
        ++p| !macro_end
        ++| 
        ++| 
        ++| //------------------------------------------------------------------------------
        ++| 
        ++| 
        ++| //  Description:
        ++| //  Floods "1"'s from the boundary of the 256x256 array into all areas that can be reached that are not inhibited by "0"'s in $r1.
        ++| //  The flooded area is stored in R12.
        ++| // Inputs:
        ++| //  $r1 (Can be R5..R11)
        ++| // Destroys:
        ++| //  FL, R1, R2, R3, R4
        ++| // Outputs:
        ++| //  R12 (always)
        ++| // Comments
        ++| //  $r1 is the mask that you want to apply to inhibit/allow propagation. "0" inhibits
        ++| //  Result in R12 ALWAYS
        ++| //  Timing works for propagating at 16MHz across half the array (from all directions)
        ++| //  May not work at lower frequencies because of need to refresh perhaps or maybe delete some prop statements
        ++p| !macro_def
        ++pg|     $ret = pro.flood_from_boundary($r1)
        ++pg| !macro_begin
        ++p|     _exp(4, IPU_PORT_CLK_SWITCH)
        ++p|     _nop
        ++p|     R0 = 1
        ++p|     R1 = 1
        ++p|     R2 = 1
        ++p|     R3 = 1
        ++p|     R4 = 1 //Sets -up direction
        ++p|     R12 = 0 //R12 is our prop. register. Must always be initialised to zero for a prop from boundary
        ++p|     R0 = $r1 //loads up mask
        ++p| keep
        ++p|     set('RR12' 'plrb' 'bit' 'bitmode') //discharges all Write Buses
        ++p|   _exp(1,IPU_PORT_RISE_C1) 
        ++p|   _exp(2,IPU_PORT_FALL_C1) 
        ++p|   _exp(3,IPU_PORT_RISE_C2) 
        ++p|   _exp(10,IPU_PORT_FALL_C2)
        ++p| //This set of propagations is enough to propagate across 75% of the array. Generally 50% is enough
        ++p|    set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'pupd' 'float' ) //precharges all read buses and starts propagation
        ++p|    set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'pupd' 'float' )  
        ++p|    set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'pupd' 'float' ) 
        ++p|    set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'pupd' 'float' )
        ++p|    set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'pupd' 'float' )
        ++p|    set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'pupd' 'float' )
        ++p|    set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'pupd' 'float' )
        ++p|    set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'pupd' 'float' )
        ++p|   _exp(1,IPU_PORT_RISE_C1) 
        ++p|   _exp(3,IPU_PORT_FALL_C1) 
        ++p|   _exp(4,IPU_PORT_RISE_C2) 
        ++p|   _exp(6,IPU_PORT_FALL_C2)
        ++p|     $ret = R12
        ++p| !macro_end
        ++| 
        ++| 
        ++| //  Description
        ++| // P.flood_from_point($r1,$r2,$r3) e.g. Prop_from_point(R5,s3,s5)
        ++| //  Writes to location x,y  and propagates to boundaries provided in digital register $r1. 
        ++| // Inputs:
        ++| //  $r1 (Can be R5..R11)
        ++| //  $r2,$r3 are the column and row ordinates
        ++| // Destroys:
        ++| //  FL, R1, R2, R3, R4 and destroys the written-to R12 (due to this holding result).
        ++| // Outputs:
        ++| //  R12 (always)
        ++| // Comments
        ++| //  $r1 is the mask that you want to apply to inhibit/allow propagation. "0" inhibits
        ++| //  Result in R12 ALWAYS
        ++| //  Timing works for propagating at 9MHz across half the array (from all directions)
        ++| //  May not work at lower frequencies because of need to refresh perhaps or maybe delete some prop statements 
        ++p| !macro_def
        ++pg|     $ret = pro.flood_from_source($r1,$r2)
        ++pg| !macro_begin
        ++p|     _exp(4, IPU_PORT_CLK_SWITCH)
        ++p|     _nop
        ++p|     R0 = 1
        ++p|     R1 = 1
        ++p|     R2 = 1
        ++p|     R3 = 1
        ++p|     R4 = 1 //This should be needed to load R12 but works without
        ++p|     R12 = $r2
        ++p|     R0 = $r1 //loading flag from my hole image
        ++p|     set('RR12' 'plrb' 'bit' 'bitmode') //discharge plwb, except for start pixel
        ++p|     _exp(4, IPU_PORT_CLK_SWITCH)
        ++p|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' ) //i.e. pupd=0. Boundary is zero.
        ++p|     _exp(0,IPU_PORT_RISE_C2)
        ++p|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' )
        ++p|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' )
        ++p|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' )
        ++p|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' )
        ++p|     //set('LR12' 'RR12' 'rid' 'nb' 'float' 'setf') //setting flag for next instr.
        ++p|     _exp(4,IPU_PORT_RISE_C2)
        ++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        ++p|     _exp(0, IPU_PORT_RD)
        ++p|     $ret = R12
        ++p| !macro_end
        ++| 
        ++| 
        ++|  
        ++| //Description
        ++| //Diffuses $r2 into $r1 e.g. A = SimpDiff(B, 1, 1)
        ++| //Destroys R11  
        ++| //Inputs 
        ++| // $r3 = [1/0] controls diffusion in NORTH-SOUTH direction ("1" is on)
        ++| // $r4 = [1/0] controls diffusion in EAST-WEST direction ("1" is on)
        ++| // Analog register $r2 
        ++| // //A good differential diffusion:
        ++| //  C = SimpDiff(A, 1, 1)
        ++| //  D = C
        ++| //  A = 
        ++| //  C = SimpDiff(A, 1, 1)
        ++| //  B = C+D
        ++| // Outputs: Analog register $r1
        ++p| !macro_def
        ++pg|     $r1 = pro.diffuse($r2, $r3, $r4)        
        ++pg| !macro_begin
        ++p|     R0 = 1
        ++p|     R3 = 1
        ++p|     R1 = $r3 //Controls North-South direction
        ++p|     R2 = $r4 //Controls EAST-WEST direction
        ++p|     set('RR3') //pulls down read bus
        ++p|     F = diff($r2 'south' 'east') //do the diffusion
        ++p|     $r1 = F
        ++p| !macro_end
        ++| 
        ++| 
        ++| 
        ++| //------------------------------------------------------------------------------
        ++| 
        ++| 
        ++| 
        ++p| !macro_def
        ++pg|     pro.locate_event($r1,$p2,$p3)
        ++pg| !macro_begin
        ++p|     
        ++p|     _exp(4,IPU_PORT_CLK_SWITCH) //returns clocks back to normal (9MHz at 90MHz clk)
        ++p|     _nop
        ++p| //    _exp(1,IPU_PORT_RISE_C1)
        ++p| 
        ++p| 
        ++p| //     _exp(5,IPU_PORT_FALL_C1)
        ++p| //     _exp(6,IPU_PORT_RISE_C2)
        ++p|     
        ++p|     _exp(255, IPU_PORT_ADDR)//search all rows
        ++p|     _exp(1, IPU_PORT_LRX)
        ++p|     _exp(0, IPU_PORT_LRX)
        ++p|     
        ++p|     _exp(0, IPU_PORT_ADDR) 
        ++p|     _exp(1, IPU_PORT_LCX)
        ++p|     _exp(0, IPU_PORT_LCX)
        ++p|     _exp(1, IPU_PORT_LC)//leave latch up on col
        ++p|     _exp(0, IPU_PORT_LC)
        ++p|     
        ++p|     R1 = $r1
        ++p|     R2 = $r1
        ++p|     
        ++p|     all
        ++p|     where($r1)
        ++p| _exp(2,IPU_PORT_FALL_C1)
        ++p| _exp(7,IPU_PORT_RISE_C2) //make this a count of 2 if running at 180MHz
        ++p| _exp(8,IPU_PORT_FALL_C2)    
        ++p|     _exp(4, IPU_PORT_CLK_SWITCH)
        ++p|     _nop
        ++p|     
        ++p|     set( 'pgdb' 'pgdbobus' 'col_out' ) //output first live column (all rows active)
        ++p|     keep
        ++p|     set( 'col_out' )
        ++p|   //  _exp(1, IPU_PORT_RD)
        ++p|  //   _exp(255, IPU_PORT_CLK_SWITCH)//FAST
        ++p| //     _nop
        ++p| //     _nop
        ++p| //     _nop
        ++p| //     _nop
        ++p| //     _nop        
        ++p|     _imp(sx, 234)//Get data from Dig port
        ++p| //     _exp(0, IPU_PORT_RD)
        ++p|     _exp(sx, IPU_PORT_ADDR) //Specifies which column searched (that is, the column just found above). 
        ++p|     _exp(1, IPU_PORT_LC)
        ++p|     _exp(0, IPU_PORT_LC)
        ++p|     
        ++p|     _exp(4,IPU_PORT_CLK_SWITCH) // dreg operation clock
        ++p|     _nop
        ++p|     R1 = $r1
        ++p|     R2 = $r1
        ++p|     
        ++p| //     _exp(4, IPU_PORT_CLK_SWITCH)
        ++p| //     _nop
        ++p|     
        ++p|     set( 'pgdb' 'row_out' )
        ++p|     keep
        ++p|     set( 'row_out' )
        ++p|   //  _exp(1, IPU_PORT_RD)
        ++p|  //   _exp(255, IPU_PORT_CLK_SWITCH) //FAST
        ++p| //     _nop
        ++p| //     _nop
        ++p| //     _nop
        ++p| //     _nop
        ++p| //     _nop
        ++p|     _imp(sy,234)//Now have row coord of pixel found in column y=s3 x=s5
        ++p| //     _exp(0, IPU_PORT_RD)
        ++p|     _mov($p2,255)
        ++p|     _sub($p2,sx)
        ++p|     _mov($p3,sy)
        ++p|     
        ++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        ++p|     _nop
        ++p|     _exp(1,IPU_PORT_FALL_C1)
        ++p| _exp(5,IPU_PORT_FALL_C1)
        ++p| _exp(6,IPU_PORT_RISE_C2) //make this a count of 2 if running at 180MHz
        ++p| _exp(9,IPU_PORT_FALL_C2)
        ++p| 
        ++p| //     _exp(0, IPU_PORT_RD)
        ++p| //     _nop
        ++p|     
        ++p|     all
        ++p|     
        ++p| !macro_end
        ++| 
        ++| 
        ++| 
        ++| //------------------------------------------------------------------------------
        ++| 
        ++| 
        ++| 
        ++p| !macro_def
        ++pg|     pro.scan_target($r1,$p0,$p1,$p2,$p3)
        ++pg| !macro_begin
        ++p|     
        ++p|     
        ++p|     _exp(255, IPU_PORT_CLK_SWITCH)
        ++p|     _exp(1, IPU_PORT_RD)
        ++p|     
        ++p|     // do the scanning
        ++p|     
        ++p|     _exp(255, IPU_PORT_ADDR) //search all rows
        ++p|     _exp(1, IPU_PORT_LRX)
        ++p|     _exp(0, IPU_PORT_LRX)
        ++p|     _exp(255, IPU_PORT_ADDR) //search all col
        ++p|     _exp(1, IPU_PORT_LCX)
        ++p|     _exp(0, IPU_PORT_LCX)
        ++p|     
        ++p|     _exp(0, IPU_PORT_ADDR)
        ++p|     _exp(1, IPU_PORT_LC)
        ++p|     _exp(0, IPU_PORT_LC)
        ++p|     _exp(1, IPU_PORT_LR)
        ++p|     _exp(0, IPU_PORT_LR)
        ++p|     
        ++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        ++p|     _nop
        ++p|     _exp(0, IPU_PORT_RD)
        ++p|     _nop
        ++p|     R0 = $r1
        ++p|     $r1 = R0
        ++p|     nop
        ++p|     nop
        ++p|     nop
        ++p|     nop
        ++p|     _exp(4, IPU_PORT_CLK_SWITCH) //returns clocks back to normal (9MHz at 90MHz clk)
        ++p|     _nop
        ++p|     
        ++p|     all
        ++p|     where($r1)
        ++p|     
        ++p|     _exp(2,IPU_PORT_FALL_C1)
        ++p|     _exp(7,IPU_PORT_RISE_C2) //make this a count of 2 if running at 180MHz
        ++p|     _exp(8,IPU_PORT_FALL_C2)    
        ++p|     
        ++p|     _exp(4, IPU_PORT_CLK_SWITCH)
        ++p|     _nop
        ++p|     
        ++p|     set( 'pgdb' 'pgdbobus' 'col_out' 'dir' 'sin') //output first live column (all rows active)
        ++p|     keep
        ++p|     set( 'col_out' 'dir' )
        ++p|     _imp(sx,234) //Get data from Dig port
        ++p|     
        ++p|     _exp(4,IPU_PORT_CLK_SWITCH) // dreg operation clock
        ++p|     _nop
        ++p|     
        ++p|     
        ++p|     set( 'pgdb' 'row_out' )
        ++p|     keep
        ++p|     set( 'row_out' )
        ++p|     _imp(sy,234)//Now have row coord of pixel found in column y=s3 x=s5
        ++p|     
        ++p|      // store coordinates
        ++p| //     _mov($p0,255)
        ++p| //     _sub($p0,sx)
        ++p|     _mov($p0,sx)
        ++p|     _mov($p1,sy)
        ++p| 
        ++p|     
        ++p|     _exp(2,IPU_PORT_FALL_C1)
        ++p|     _exp(7,IPU_PORT_RISE_C2) //make this a count of 2 if running at 180MHz
        ++p|     _exp(8,IPU_PORT_FALL_C2)    
        ++p|     
        ++p|     _exp(4, IPU_PORT_CLK_SWITCH)
        ++p|     _nop
        ++p|     
        ++p|     set( 'pgdb' 'pgdbobus' 'col_out' 'sin') //output last live column (all rows active)
        ++p|     keep
        ++p|     set( 'col_out' )  
        ++p|     _imp(sx,234) //Get data from Dig port
        ++p|     
        ++p|     _exp(4,IPU_PORT_CLK_SWITCH) // dreg operation clock
        ++p|     _nop
        ++p|     
        ++p|     
        ++p|     set( 'pgdb' 'row_out' 'dir' )
        ++p|     keep
        ++p|     set( 'row_out' 'dir' )
        ++p|     _imp(sy,234)//Now have row coord of pixel found in column y=s3 x=s5
        ++p|     
        ++p|      // store coordinates
        ++p| //     _mov($p2,255)
        ++p| //     _sub($p2,sx)
        ++p|     _mov($p2,sx)
        ++p|     _mov($p3,sy)
        ++p|     
        ++p|     
        ++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        ++p|     _nop
        ++p|     _exp(1,IPU_PORT_FALL_C1)
        ++p|     _exp(5,IPU_PORT_FALL_C1)
        ++p|     _exp(6,IPU_PORT_RISE_C2) //make this a count of 2 if running at 180MHz
        ++p|     _exp(9,IPU_PORT_FALL_C2)
        ++p|     
        ++p|     all
        ++p|     
        ++p|     _exp(8, IPU_PORT_CLK_SWITCH)
        ++p|     _nop
        ++p|     
        ++p| !macro_end
        ++| 
        ++| 
        ++| 
        ++| //------------------------------------------------------------------------------
        ++| 
        ++| 
        ++| 
        ++p| !macro_def
        ++pg|     Wr_Code_to_Dig_Reg($r2,$r1)
        ++pg| !macro_begin
        ++p| //Aim is to save a code stored in IPU register $r1 to Scamp registers R8 to R1 inclusive
        ++p| //Overwrites IPU registers su and sv and sw
        ++p|     _mov(su, 128) //start with saving the MSB
        ++p|     all
        ++p|     where($r2)
        ++p|     //Bit 7
        ++p|     R0 = 1 //R0 is the register formerly known as FL
        ++p|             R12 = R8 //preload R12 with whatever R8 used to be
        ++p|             _call(#Conditionally_load_Scamp_from_IPU)
        ++p|             _nop
        ++p|             R8 = R12 //Save back R12 into R8
        ++p|     //bit 6 
        ++p|             R12 = R7
        ++p|             _call(#Conditionally_load_Scamp_from_IPU)
        ++p|             _nop
        ++p|             R7 = R12
        ++p|     //bit 5 
        ++p|             R12 = R6
        ++p|             _call(#Conditionally_load_Scamp_from_IPU)
        ++p|             _nop
        ++p|             R6 = R12 
        ++p|     //bit 4 
        ++p|             R12 = R5
        ++p|             _call(#Conditionally_load_Scamp_from_IPU)
        ++p|             _nop
        ++p|             R5 = R12 
        ++p|     //bit 3 
        ++p|             R12 = R4
        ++p|             _call(#Conditionally_load_Scamp_from_IPU)
        ++p|             _nop
        ++p|             R4 = R12 
        ++p|     //bit 2 
        ++p|             R12 = R3
        ++p|             _call(#Conditionally_load_Scamp_from_IPU)
        ++p|             _nop
        ++p|             R3 = R12 
        ++p|     //bit 1 
        ++p|             R12 = R2
        ++p|             _call(#Conditionally_load_Scamp_from_IPU)
        ++p|             _nop
        ++p|             R2 = R12 
        ++p|     //bit 0 
        ++p|             R12 = R1
        ++p|             _call(#Conditionally_load_Scamp_from_IPU)
        ++p|             _nop
        ++p|             R1 = R12
        ++p|              _exp(255, IPU_PORT_CLK_SWITCH)
        ++p|             _exp(8, IPU_PORT_CLK_SWITCH)
        ++p|             _exp(5,IPU_PORT_FALL_C1)
        ++p|             _exp(6,IPU_PORT_RISE_C2)
        ++p|             _nop
        ++p|             _jump(#end)
        ++p|             _nop
        ++p|             #Conditionally_load_Scamp_from_IPU
        ++p|             _nop
        ++p|             R0 = FLAG //Setting conditional load. So overwrites R12 dependant upon the where(B) condition above
        ++p|                      //MSB first?
        ++p|             R12 = 0
        ++p|             _mov(sw,$r1) //$r1 has my counter
        ++p|            //   _mov(sw, 1)
        ++p|             _and(sw, su) //AND sw and su, result in sw. su starts with 128. ANDs Counter with a bit (start with MSB)
        ++p|             _jump(z, #setzero)
        ++p|             _nop
        ++p|             R12 = 1
        ++p|             #setzero
        ++p|             _nop
        ++p|             _shl(sv,su) 
        ++p|             _mov(su,sv)// Last 2 ops. su now shifted right (yes "right") by 1.  su=128 changed to su=64 etc
        ++p|             FL = 1
        ++p|             _ret
        ++p|             #end
        ++p|             _nop
        ++p| !macro_end
        ++| 
        ++p| !macro_def
        ++pg|     Set_pixels_in_address_range($r5,$r1,$r2,$r3,$r4)
        ++pg| !macro_begin
        ++p| 	//x1,x2,y1,y2
        ++p| 	_exp(0, IPU_PORT_ADDR) //search all col
        ++p|     _exp(1, IPU_PORT_LCX)
        ++p|     _exp(0, IPU_PORT_LCX)
        ++p|     _exp(1, IPU_PORT_LRX)
        ++p|     _exp(0, IPU_PORT_LRX)
        ++p|      _exp($r1, IPU_PORT_ADDR)
        ++p|     _exp(1, IPU_PORT_LC)
        ++p|     _exp(0, IPU_PORT_LC) 
        ++p|     _exp($r3, IPU_PORT_ADDR)
        ++p|     _exp(1, IPU_PORT_LR)
        ++p|     _exp(0, IPU_PORT_LR)
        ++p|      set( 'g_start'  )
        ++p|     _exp($r2, IPU_PORT_ADDR)
        ++p|     _exp(1, IPU_PORT_LC)
        ++p|     _exp(0, IPU_PORT_LC)
        ++p|     _exp($r4, IPU_PORT_ADDR)
        ++p|     _exp(1, IPU_PORT_LR)
        ++p|     _exp(0, IPU_PORT_LR)
        ++p|     set( 'g_stop'  )
        ++p|     set('wr' 'plrb' xL$r5 'bit' 'bitmode' 's0_left' 's0_bot')
        ++p| !macro_end
        ++| 
        ++p| !macro_def
        ++pg| 	$r1 = GlobalOR($r2)		
        ++pg| !macro_begin
        ++p| 	_exp(0, IPU_PORT_ADDR) 
        ++p| 	_exp(1, IPU_PORT_LR)
        ++p| 	_exp(0, IPU_PORT_LR)
        ++p| 	_exp(1, IPU_PORT_LC)
        ++p| 	_exp(0, IPU_PORT_LC)
        ++p| 	_exp(255, IPU_PORT_ADDR)
        ++p| 	_exp(1, IPU_PORT_LRX)
        ++p| 	_exp(0, IPU_PORT_LRX)
        ++p| 	_exp(1, IPU_PORT_LCX)
        ++p| 	_exp(0, IPU_PORT_LCX) 		
        ++p| 	where($r2)
        ++p| 	_nop
        ++p| 	set( 'pgdb'  'pgdbobus' 'col_out') //includes where(R7)
        ++p| 	set(  'dig8' )
        ++p| 	_exp(255, IPU_PORT_CLK_SWITCH)//FAST
        ++p| //	_nop
        ++p| 	_imp($r1, 245)
        ++p| 	_exp(4, IPU_PORT_CLK_SWITCH)
        ++p| 	_nop
        ++p| !macro_end	
        +| 
        +p| !include('scamp5c/scamp5c_calibration.aps')
        ++| 
        ++p| !macro_def
        ++pg|     ipu.analog_calibrate
        ++pg| !macro_begin
        ++p| 	_nop
        ++p| _exp(19, IPU_PORT_POWER) //power up Analog
        ++p| _nop
        ++p|     _nop
        ++p|     _exp(7 , IPU_PORT_ADC_FEAMP) //Power up op-amps
        ++p|     _exp(32, IPU_PORT_CLK_SWITCH)//really slow clock
        ++p|     _nop
        ++p|     _exp(19, IPU_PORT_POWER) //power up Analog
        ++p|     _exp(27, IPU_PORT_POWER) //Enable scamp
        ++p|     _exp(25, IPU_PORT_POWER) //Unsnooze smps
        ++p|     _call(#_ipu_st_delay)
        ++p|     _nop
        ++p|     _exp(57, IPU_PORT_POWER) //Power up DAC opamp
        ++p|     _exp(121, IPU_PORT_POWER) //Power up DAC 
        ++p|     _exp(249, IPU_PORT_POWER) //Unclr DAC
        ++p|     _exp(248, IPU_PORT_POWER) //POwer up ADC
        ++p|     _call(#_ipu_st_delay)
        ++p|     _nop
        ++p|     _call(#_ipu_st_delay)
        ++p|     _nop
        ++p|     _call(#_ipu_st_delay)
        ++p|     _nop
        ++p|     _call(#_ipu_st_delay)
        ++p|     _nop
        ++p|     _exp(252, IPU_PORT_POWER) //POwer up VDDA
        ++p|     _exp(32, IPU_PORT_CLK_SWITCH)//really slow clock
        ++p|     _nop
        ++p| 
        ++p|     
        ++p|     _nop
        ++p| 
        ++p| 	_exp(4, IPU_PORT_CLK_SWITCH) //returns clocks back to normal (9MHz at 90MHz clk)
        ++p| 	_nop
        ++p| 	_exp(0,IPU_PORT_calib)
        ++p| 	_exp(0, IPU_PORT_RD)
        ++p| 	_exp(8, IPU_PORT_DACS) //Vdiv2
        ++p| 	_exp(70, IPU_PORT_B) //Vdiv2
        ++p| 	_exp(9, IPU_PORT_DACS)//Vres
        ++p| 	_exp(79, IPU_PORT_B)//Vres //75 1st system, 79 second
        ++p| 	_exp(10, IPU_PORT_DACS) //Vdiff
        ++p| 	_exp(211, IPU_PORT_B)//Vdiff
        ++p| 	_exp(11, IPU_PORT_DACS)//vxc
        ++p| 	_exp(158, IPU_PORT_B)//vxc //was 158 for other boxes
        ++p| 	_exp(12, IPU_PORT_DACS) //pbias
        ++p| 	_exp(211, IPU_PORT_B)//pbias
        ++p| 	_exp(13, IPU_PORT_DACS)//vdiv1
        ++p| 	_exp(67, IPU_PORT_B)//vdiv1
        ++p| 	_exp(14, IPU_PORT_DACS) //cbias
        ++p| 	_exp(63, IPU_PORT_B)//cbias
        ++p| 	_exp(15, IPU_PORT_DACS)//cbus
        ++p| 	_exp(70, IPU_PORT_B)//cbus
        ++p| 		_exp(16, IPU_PORT_DACS) //ADCrefhi
        ++p| 		_exp(234, IPU_PORT_B)//ADCrefhi
        ++p| 	_exp(17, IPU_PORT_DACS)//1VrefAmpA
        ++p| 	_exp(71, IPU_PORT_B)//1VrefAmpA //was 71
        ++p| 	_exp(18, IPU_PORT_DACS) //Secampoffset
        ++p| 	_exp(122, IPU_PORT_B)//Secampoffset 105 first board! //102 and 248 first board last 102
        ++p| 	_exp(248, IPU_PORT_DACsLSBs) //Increase to increase A= ; out A return
        ++p| 	_exp(19, IPU_PORT_DACS)//1VrefAMPB
        ++p| 	_exp(68, IPU_PORT_B)//1VrefAMPB //was72
        ++p| 	_exp(0, IPU_PORT_DACsLSBs)
        ++p| 	_exp(20, IPU_PORT_DACS) //ADCreflo
        ++p| 	_exp(23, IPU_PORT_B)//ADCreflo
        ++p| 	_exp(21, IPU_PORT_DACS)//VDACbias
        ++p| 	_exp(94, IPU_PORT_B)//VDACbias
        ++p| 	_exp(22, IPU_PORT_DACS) //Vdacref
        ++p| 	_exp(164, IPU_PORT_B)//Vdacref
        ++p| 	_exp(23, IPU_PORT_DACS) //empty
        ++p| 	_exp(117, IPU_PORT_B)//empty
        ++p| 	_exp(0, IPU_PORT_DACS) //set for ordinary portB commands
        ++p| //end set voltages
        ++p| 	    _call(#_ipu_st_delay)
        ++p|     _nop
        ++p|     _call(#_ipu_st_delay)
        ++p|     _nop
        ++p| !macro_end
        ++| 
        ++p| !macro_def
        ++pg| 	SetCentres //Given a command A = {nothing}, we want output to deliver value of 0. Adjusts voltage SecAmpOffset to achieve this
        ++pg| !macro_begin
        ++p| _nop
        ++p| 	_exp(8, IPU_PORT_CLK_SWITCH) //returns clocks back to normal (9MHz at 90MHz clk)
        ++p| 	_exp(0, IPU_PORT_RD)
        ++p| 	_nop
        ++p| 	
        ++p| 	 set('wrf')
        ++p| 	 all
        ++p| 	_mov(s6,102)// Start at 106
        ++p| 	_exp(s6, IPU_PORT_B)
        ++p| 	_exp(18, IPU_PORT_DACS) //Setting SecAmpOffset
        ++p| 	_exp(s6, IPU_PORT_B)
        ++p| 	_call(#_ipu_st_delay)
        ++p| 	_nop
        ++p| 	_call(#_ipu_st_delay)
        ++p| 	_nop
        ++p| 	_call(#_ipu_st_delay)
        ++p| 	_nop
        ++p| 	_call(#_ipu_st_delay)
        ++p| 	_nop
        ++p| 		_call(#_ipu_st_delay)
        ++p| 	_nop
        ++p| 		_call(#_ipu_st_delay)
        ++p| 	_nop
        ++p| 		_call(#_ipu_st_delay) //Delay insertion turns out to be somewhat critical...
        ++p| 	_nop
        ++p| 			_call(#_ipu_st_delay)
        ++p| 	_nop
        ++p| 	_call(#_ipu_st_delay)
        ++p| 	_nop
        ++p| 
        ++p| 	 #CcycleMSBB
        ++p| 	 _nop
        ++p| 	 _mov(s5,240) //Start at 0. 240 is "zero" when you look at the 4 LSBs. A bug in hardware perhaps
        ++p| 	 #CcycleLSBB
        ++p| 	 _nop
        ++p| 	 _exp(6,248)
        ++p| 	 _exp(8, IPU_PORT_CLK_SWITCH) 
        ++p| 	 _exp(0, IPU_PORT_RD)
        ++p| 	_nop
        ++p| 	_call(#_ipu_st_delay)
        ++p| 	_nop
        ++p| 	 _exp(s6, IPU_PORT_B)
        ++p| 	 _nop
        ++p| 	 _exp(s5, IPU_PORT_DACsLSBs)
        ++p| 	 _nop
        ++p| 		A = 
        ++p| 	 	keep 
        ++p| 	set('SEL1' 'ana' ) 
        ++p|  	_call(#Calibreadout)
        ++p| 	 _nop
        ++p| 	 
        ++p| 	  _nop
        ++p| 	_add(sw,132)//subtract 131 from ReadData Set at 131 since it appears to work.
        ++p| 	_jump(c, #FoundCentre)//if a carry occurs it means 128 reached
        ++p| 	_nop
        ++p| 	 _add(s5,1)
        ++p| 	 _jump(nz, #CcycleLSBB)
        ++p| 	 _nop
        ++p| 	 _add(s6,1)
        ++p| 	 _jump(nz, #CcycleMSBB)
        ++p| 	  _nop
        ++p| 	  #FoundCentre
        ++p| 	  _nop
        ++p| 	  
        ++p| 	//_exp(18, IPU_PORT_DACS) //Setting SecAmpOffset
        ++p| //	_exp(62, IPU_PORT_B)
        ++p| 	//	_exp(18, IPU_PORT_DACS) //Setting SecAmpOffset
        ++p| // 	_nop
        ++p|  	 _exp(23, IPU_PORT_DACS) //empty Adding this seems to make it work better (reason?)
        ++p|  	 _exp(0, IPU_PORT_DACS) 
        ++p|  	 _nop
        ++p| !macro_end
        ++| 
        ++p| !macro_def
        ++pg| 	Calib_IN_Diff
        ++pg| !macro_begin
        ++p| 	_nop
        ++p| 	_mov(s1, 8)  //returns clocks back to normal (9MHz at 90MHz clk)
        ++p| //Now starting the IN calibration routine	
        ++p| //Bit added for running at 10MHz
        ++p| _cmp(s1,8)
        ++p| _jump(z, #skipclocks)
        ++p| _exp(0,IPU_PORT_RISE_C4)
        ++p| _exp(10,IPU_PORT_FALL_C4)
        ++p| _exp(0,IPU_PORT_RISE_C1)
        ++p| _exp(6,IPU_PORT_FALL_C1)
        ++p| _exp(6,IPU_PORT_RISE_C2)
        ++p| _exp(10,IPU_PORT_FALL_C2) //6 looks okay!
        ++p| #skipclocks
        ++p| _nop
        ++p| //End of bit added for running at 10MHz		
        ++p| 	_exp(s1, IPU_PORT_CLK_SWITCH)
        ++p| 	_nop
        ++p| 	_exp(0, IPU_PORT_DACS) 
        ++p| 	all
        ++p| 	 _exp(0, IPU_PORT_ADDR) 
        ++p| 	_exp(1, IPU_PORT_LRX)
        ++p| 	_exp(0, IPU_PORT_LRX)
        ++p| 	_exp(1, IPU_PORT_LCX)
        ++p| 	_exp(0, IPU_PORT_LCX)
        ++p| 	
        ++p| 	// Set ADC Delay
        ++p| 
        ++p| 	_exp(8, IPU_PORT_ADC_DELAY)
        ++p| 	_exp(63, IPU_PORT_ADDR) //use pixel at (63,63)
        ++p| 	_exp(1, IPU_PORT_LR)
        ++p| 	//_exp(0, IPU_PORT_LR)
        ++p| 	_exp(1, IPU_PORT_LC)
        ++p| 	//_exp(0, IPU_PORT_LC)
        ++p| 	_exp(6, 248)
        ++p| 
        ++p|  	_exp(1,IPU_PORT_calib) //OK. Now we're calibrating
        ++p|  	
        ++p|  	//First find the IN corresponding to the 128 position so can get the calibration right
        ++p|  	_mov(s6, 255)
        ++p|  	_exp(15, IPU_PORT_DACsLSBs)
        ++p|  	#Findposition
        ++p|  	_nop
        ++p|  	_sub(s6, 1)
        ++p|  	_exp(0, IPU_PORT_RD)
        ++p|  	_exp(s6, IPU_PORT_B)
        ++p|  	 F =
        ++p|  	_nop
        ++p|  	_nop
        ++p|  	_nop
        ++p|  	F = IN
        ++p|  	keep //not really needed since clocks turned off afterwards
        ++p| 	set( 'SEL7' 'ana' )
        ++p| 	_call(#Calibreadout)
        ++p| 	_nop
        ++p| 	_exp(s1, IPU_PORT_CLK_SWITCH)
        ++p|  	_exp(0, IPU_PORT_RD) 
        ++p| 	_nop
        ++p| 	_add(sw,128)//Add 128.... so will jump and repeat if not over 128.
        ++p| 	_jump(nc,#Findposition)
        ++p| 	_nop
        ++p| 	_mov(s4, s6) //s4 = s6 
        ++p| 	//So saved the 128 value in s4
        ++p| 	//Now decrementing IN values from 255
        ++p| 	_mov(s6, 255)
        ++p| 	 _exp(s4, IPU_PORT_B)
        ++p|  	_mov(s9,0) //Zero will be first element of table to be filled
        ++p|   	_call(#_ipu_st_delay)//a delay to allow the pre-filling of zero data into array
        ++p| 	_nop
        ++p| 	_mov(s6,255)// Start at highest B values=> lowest Vin => highest IN source=> lowest A values
        ++p| 	 #cycleMSBB
        ++p| 	 _nop
        ++p| 	 _mov(s5,255) //was15. The 3 LSBs seem to get stuck periodically. THe 255 start works around the D1-D2. But D0 requires that it is not used
        ++p| 	 //since it sticks at 1. So decrement by 2.
        ++p| 	 #cycleLSBB
        ++p| 	 _nop
        ++p| 	 _exp(s5, IPU_PORT_DACsLSBs)
        ++p| // 	
        ++p| 	 _exp(s4, IPU_PORT_B)// I resend 128 every time since want to keep transitions the same. 
        ++p| 	 A F = //	
        ++p| 	// set('sin')
        ++p| 	// _nop //UNDELETE this nop if trying to go at 9MHz	
        ++p| 	_nop //This nop is IMPORTANT. It matches the Set, Sin, import,set, A =IN of the IN macro. It gets timing the same - replaces the missing import that isnt needed here
        ++p| 	F = IN
        ++p| 	_exp(s6, IPU_PORT_B) //Now exporting the new DAC value
        ++p| 	// _nop //UNDELETE this nop if trying to go at 9MHz
        ++p| 	 A =  F IN
        ++p| 	 keep //not really needed since clocks turned off afterwards
        ++p| 	set( 'SEL1' 'ana' )
        ++p| 	_call(#Calibreadout)
        ++p| 	 _nop
        ++p| 	_sub(sw,s9)//subtract ReadData by s9 
        ++p| 	_jump(c, #nostoreB)//if a carry occurs it means new value is lower than previous value already stored
        ++p| 	_nop
        ++p| 	_exp(3,IPU_PORT_calib)
        ++p| 	_nop
        ++p| 	_nop
        ++p| 	_exp(1,IPU_PORT_calib)
        ++p| 	_cmp(s9,255) 
        ++p| 	_jump(z, #endB)//if the system has reached the match value 255, then the B-ramp cuts out and ends
        ++p| 	_nop
        ++p| 	_add(s9,1)//add 1 to s9 for the next mem to be filled
        ++p| 	#nostoreB
        ++p| 	_nop
        ++p| 	_exp(s1, IPU_PORT_CLK_SWITCH)
        ++p|  	_exp(0, IPU_PORT_RD) //gotta take read lo turn ordinary clocks on
        ++p| 	 _exp(s4, IPU_PORT_B) //Centres the IPU port B. Can only be done here since B value is IPU imported to store in calib file
        ++p| 	 _nop
        ++p| 	 _sub(s5,2)//CAHNGE BACK TO 1 if get LSB working
        ++p| 	 _cmp(s5,241)
        ++p| 	 _jump(nz, #cycleLSBB)
        ++p| 	 _nop
        ++p| 	 _sub(s6,1)
        ++p| 	 _jump(nz, #cycleMSBB)
        ++p| 	  _nop
        ++p| 	  #endB
        ++p| 	  _nop
        ++p| 	 _exp(0,IPU_PORT_calib)//turn calib off
        ++p| 	 _nop
        ++p| !macro_end
        ++| 
        ++| 
        ++l| #Calibreadout
        ++c| _nop	
        ++c|     _exp(255, IPU_PORT_CLK_SWITCH)
        ++c|     _nop
        ++c|       _exp(1, IPU_PORT_RD)
        ++c|     _exp(7, IPU_PORT_ADC_FEAMP)
        ++|  
        ++|     // image header packet
        ++|   
        ++|     
        ++|     // Set Block Size
        ++| //     _exp(255, IPU_PORT_ADDR) //was0
        ++| //     _exp(1, IPU_PORT_LRX)
        ++| //     _exp(0, IPU_PORT_LRX)
        ++| //     _exp(1, IPU_PORT_LCX)
        ++| //     _exp(0, IPU_PORT_LCX)
        ++|     
        ++c|         _exp(0, IPU_PORT_ADDR) //was0
        ++c|     _exp(1, IPU_PORT_LRX)
        ++c|     _exp(0, IPU_PORT_LRX)
        ++c|     _exp(1, IPU_PORT_LCX)
        ++c|     _exp(0, IPU_PORT_LCX)
        ++|     
        ++|     // Set ADC Delay
        ++| 
        ++c|     _exp(8, IPU_PORT_ADC_DELAY) //For this algo, the critical factor is how well IN matches calibration (which is based on the other readout routine)
        ++|     //Increasing speed destroys calibration at high end
        ++|   
        ++c|     _exp(63, IPU_PORT_ADDR) 
        ++c|     _exp(1, IPU_PORT_LR)
        ++c|     _exp(0, IPU_PORT_LR)
        ++c|     _exp(1, IPU_PORT_LC)
        ++c|     _exp(0, IPU_PORT_LC)
        ++|     
        ++|      // 255 dummy samples to smooth out acquisition
        ++| //     _mov(su,0)
        ++| //     #dummy22
        ++| //         _nop
        ++| //         _call(#_ipu_sw_sample_ana)
        ++| //         _add(su, 1)
        ++| //     _jump(nz, #dummy22)
        ++| //     _nop
        ++|     
        ++|     // whole plane sampling loop
        ++c|     _mov(sy, 60)
        ++l|     #rm_loop_row2
        ++c|         _nop
        ++c|          _exp(7, IPU_PORT_ADC_FEAMP)
        ++|         // row address
        ++c|         _exp(0, IPU_PORT_LC)
        ++c|         _exp(sy, IPU_PORT_ADDR) 
        ++c|         _exp(1, IPU_PORT_LR)
        ++c|         _exp(0, IPU_PORT_LR)
        ++|         
        ++|         // column address
        ++c|          _exp(sx, IPU_PORT_ADDR)
        ++c|           _exp(1, IPU_PORT_LC)
        ++c|         _mov(sx, 0)
        ++c|         _exp(sx, IPU_PORT_ADDR) 
        ++|          
        ++|        
        ++| //        
        ++c| _nop
        ++c|          _exp(6, IPU_PORT_ADC_FEAMP)
        ++|  
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++|         
        ++|         
        ++l|         #rm_loop_col2
        ++c|             _nop
        ++|             
        ++c|             _add(sx, 1)
        ++|             
        ++|             // sample and store in sw
        ++c|             _call(#_ipu_sw_sample_ana)
        ++|                       // column address
        ++c|                       _nop
        ++c|            _exp(7 , IPU_PORT_ADC_FEAMP) //Set low gain
        ++c|             _exp(sx, IPU_PORT_ADDR)
        ++| //             _exp(1, IPU_PORT_LC)
        ++| //             _exp(0, IPU_PORT_LC)
        ++| //_exp(0, IPU_PORT_RD)
        ++| 		//	_mov(sw, s9)
        ++c|             _exp(6, IPU_PORT_ADC_FEAMP) //Set high gain
        ++|              //_exp(1, IPU_PORT_RD)
        ++c|              _nop
        ++c|             _nop
        ++c|              _nop //Three nops worked for boxes 0 and 2
        ++c|              _nop
        ++|      //        _nop //Five for box 1
        ++| //              _nop
        ++| //              _nop
        ++| //                           _nop
        ++| //              _nop
        ++| //                           _nop
        ++| //              _nop
        ++| //      
        ++|          
        ++c|             _cmp(sx,63)
        ++c|         _jump(nz, #rm_loop_col2)
        ++c|         _nop
        ++|         
        ++c|         _add(sy, 1)
        ++c|         _cmp(sy,63)
        ++c|     _jump(nz, #rm_loop_row2)
        ++c|     _nop	
        ++| 	
        ++| 	
        ++c| _ret
        ++| 
        +| 
        +p| !include('scamp5c/scamp5c_host_and_sim.aps')
        ++| 
        ++p| !macro_def
        ++pg|     sim.load_pix
        ++pg| !macro_begin
        ++p|     // ignored
        ++p| !macro_end
        ++| 
        ++| 
        ++p| !macro_def
        ++pg|     sim.pix_source_webcam
        ++pg| !macro_begin
        ++p|     // ignored
        ++p| !macro_end
        ++| 
        ++| 
        ++p| !macro_def
        ++pg|     sim.pix_source_image($p1)
        ++pg| !macro_begin
        ++p|     // ignored
        ++p| !macro_end
        ++| 
        ++| 
        ++p| !macro_def
        ++pg|     sim.pix_source_video($p1)
        ++pg| !macro_begin
        ++p|     // ignored
        ++p| !macro_end
        ++| 
        ++| 
        ++p| !macro_def
        ++pg|     sim.use_error_model($p1)
        ++pg| !macro_begin
        ++p|     // ignored
        ++p| !macro_end
        ++| 
        ++| 
        +| 
        +| //------------------------------------------------------------------------------
        +| 
        +c| _jump(#program_entry)
        +| 
        +| //------------------------------------------------------------------------------
        +| 
        +p| !include('scamp5c/scamp5c_routine.aps')
        ++| //
        ++| // IPU Routines (not to be used directly in user algorithms)
        ++| // 
        ++| // Aliased IPU registers:
        ++| // su -- s15
        ++| // sv -- s14
        ++| // sw -- s13
        ++| // sx -- s12
        ++| // sy -- s11
        ++| // sz -- s10
        ++| // 
        ++| // Assuming a number of volatile registers, indiceted in name as follow:
        ++| // sa -- su, sv, sw, sx, sy, sz,
        ++| // sh -- su, sv, sw,
        ++| // st -- su, sv,
        ++| // sw --         sw.
        ++| // 
        ++| // If a routine produces a result, the result will always be stored in sw.
        ++| //
        ++| //------------------------------------------------------------------------------
        ++| 
        ++l| #_ipu_st_delay
        ++| 
        ++c|     _nop
        ++|     
        ++c|     _mov(su,5)
        ++l|     #delay_outer_loop
        ++c|         _nop
        ++|         
        ++c|         _mov(sv,255)
        ++l|         #delay_inner_loop
        ++c|             _nop
        ++c|             _sub(sv,1)
        ++c|         _jump(nz,#delay_inner_loop)
        ++c|         _nop
        ++|         
        ++c|         _sub(su,1)
        ++c|     _jump(nz,#delay_outer_loop)
        ++c|     _nop
        ++|     
        ++c| _ret
        ++| 
        ++| //------------------------------------------------------------------------------
        ++| 
        ++l| #_ipu_su_delay_50us
        ++c| _nop
        ++c|     _exp(0, IPU_PORT_B)
        ++c|     keep
        ++c|     set('sin')
        ++c|     _exp(32, IPU_PORT_CLK_SWITCH)// slow clocks so dont have to count too high
        ++c|     _exp(1, IPU_PORT_RD)
        ++l|     #delay_u
        ++c|     _nop
        ++c|         _mov(sv, 9)
        ++l|         #delay_v
        ++c|         _nop
        ++c|         _sub(sv, 1)
        ++c|         _jump(nz,#delay_v)
        ++c|         _nop
        ++c|     _sub(su, 1)
        ++c|     _jump(nz,#delay_u)
        ++c|     _nop
        ++c|     _exp(8, IPU_PORT_CLK_SWITCH)
        ++c|     _exp(0, IPU_PORT_RD)
        ++c| _ret
        ++c| _nop
        ++| 
        ++| //------------------------------------------------------------------------------
        ++| 
        ++l| #_ipu_sw_sample_ana
        ++|     
        ++c|     _exp(1, IPU_PORT_ADC_START_SAMPLE)
        ++|     
        ++l|     #sample_ana_loop
        ++c|         _imp(sw, IPU_PORT_ADC_STOP_SAMPLE)
        ++c|         _and(sw, 1)
        ++c|     _jump(z,#sample_ana_loop)
        ++|     
        ++c|     _exp(0, IPU_PORT_ADC_START_SAMPLE)
        ++|     
        ++c|     _imp(sw, IPU_PORT_NO_VC_DI)
        ++|     
        ++c| _ret
        ++| 
        ++| //------------------------------------------------------------------------------
        ++| 
        ++l| #_ipu_sa_pixel_set
        ++c|     _nop
        ++|     
        ++c|     _exp(1, IPU_PORT_RD) //clocks off
        ++c|     _exp(255, IPU_PORT_CLK_SWITCH) //FAST
        ++c|     _exp(sy, IPU_PORT_ADDR)
        ++c|     _exp(1, IPU_PORT_LR)
        ++c|     _exp(0, IPU_PORT_LR)
        ++c|     _mov(su, 255)
        ++c|     _sub(su, sx)
        ++c|     _exp(su, IPU_PORT_ADDR)
        ++c|     _exp(1, IPU_PORT_LC)
        ++c|     _exp(0, IPU_PORT_LC)
        ++c|     _exp(0, IPU_PORT_ADDR) 
        ++c|     _exp(1, IPU_PORT_LCX)
        ++c|     _exp(0, IPU_PORT_LCX)
        ++c|     _exp(1, IPU_PORT_LRX)
        ++c|     _exp(0, IPU_PORT_LRX)
        ++c|     _exp(4, IPU_PORT_CLK_SWITCH) //9Mhz
        ++c|     _exp(0, IPU_PORT_RD) //clocks on
        ++c|     set('lfl' 'wr' 'bitmode' 'bit' 'plrb')//write to the pixel
        ++c|     _exp(1, IPU_PORT_RD)
        ++c|     _exp(255, IPU_PORT_CLK_SWITCH)
        ++c|     _exp(8, IPU_PORT_CLK_SWITCH)
        ++c|     _nop
        ++c|     _exp(0, IPU_PORT_RD)
        ++|     
        ++c| _ret
        ++c| _nop
        ++| 
        ++| //------------------------------------------------------------------------------
        ++| 
        ++l| #_ipu_sa_pixel_select
        ++c|     _nop
        ++|     
        ++c|     _exp(255, IPU_PORT_CLK_SWITCH) //FAST
        ++|     
        ++c|     _exp(sy, IPU_PORT_ADDR)//y
        ++c|     _exp(1, IPU_PORT_LR)
        ++c|     _exp(0, IPU_PORT_LR)
        ++c|     _exp(sx, IPU_PORT_ADDR)//x
        ++c|     _exp(1, IPU_PORT_LC)
        ++c|     _exp(0, IPU_PORT_LC)
        ++|     
        ++c|     _exp(su, IPU_PORT_ADDR)//
        ++c|     _exp(1, IPU_PORT_LCX)
        ++c|     _exp(0, IPU_PORT_LCX)
        ++c|     _exp(sv, IPU_PORT_ADDR)//
        ++c|     _exp(1, IPU_PORT_LRX)
        ++c|     _exp(0, IPU_PORT_LRX)
        ++|     
        ++c|     _exp(0, IPU_PORT_RD) //clocks on
        ++c|     _exp(4, IPU_PORT_CLK_SWITCH) //9Mhz
        ++c|     _exp(6, IPU_PORT_RISE_C2)
        ++c|     _exp(5, IPU_PORT_FALL_C1)
        ++c|     set('lfl' 'wr' 'bitmode' 'bit' 'plrb')//write to the pixel
        ++c|     _exp(8, IPU_PORT_CLK_SWITCH)
        ++|     
        ++c| _ret
        ++c| _nop
        ++| 
        ++| //------------------------------------------------------------------------------
        ++| 
        ++p| !endif
        ++| 
        ++| //------------------------------------------------------------------------------
        ++| 
        ++p| !if(USE_CALL_USB_AOUT_256_ROW_MAJOR, ==, 1)
        ++| 
        ++| //This readout algo looks better than the Row version since less streaking is visible from other pixels. However, there does appear to be a shift of pixel value if run at high speed.
        ++| //Add a square block of significant different intensity to see streaking effect that this algo avoids.
        ++l| #_ipu_sa_readout_256_rm
        ++|     
        ++|     // boost clocks
        ++c|     _exp(255, IPU_PORT_CLK_SWITCH)
        ++c|     _nop
        ++c|     _exp(7, IPU_PORT_ADC_FEAMP)
        ++|     // image header packet
        ++m|     ipu.send_byte(PCKT_START)
        +++l|     #ipu.send_byte.wait_usb_buffer_^3_2
        +++|     // Check buffer has space
        +++c|     _imp(su, IPU_PORT_NO_USB_FLAGS)
        +++c|     _and(su, 1)
        +++c|     _jump(nz,#ipu.send_byte.wait_usb_buffer_^3_2)
        +++|     // Write byte
        +++c|     _exp(85,IPU_PORT_NO_IPU_DO)
        ++m|     ipu.send_byte(6)
        +++l|     #ipu.send_byte.wait_usb_buffer_^3_3
        +++|     // Check buffer has space
        +++c|     _imp(su, IPU_PORT_NO_USB_FLAGS)
        +++c|     _and(su, 1)
        +++c|     _jump(nz,#ipu.send_byte.wait_usb_buffer_^3_3)
        +++|     // Write byte
        +++c|     _exp(6,IPU_PORT_NO_IPU_DO)
        ++m|     ipu.send_byte(0) // x-min
        +++l|     #ipu.send_byte.wait_usb_buffer_^3_4
        +++|     // Check buffer has space
        +++c|     _imp(su, IPU_PORT_NO_USB_FLAGS)
        +++c|     _and(su, 1)
        +++c|     _jump(nz,#ipu.send_byte.wait_usb_buffer_^3_4)
        +++|     // Write byte
        +++c|     _exp(0,IPU_PORT_NO_IPU_DO)
        ++m|     ipu.send_byte(0) // y-min
        +++l|     #ipu.send_byte.wait_usb_buffer_^3_5
        +++|     // Check buffer has space
        +++c|     _imp(su, IPU_PORT_NO_USB_FLAGS)
        +++c|     _and(su, 1)
        +++c|     _jump(nz,#ipu.send_byte.wait_usb_buffer_^3_5)
        +++|     // Write byte
        +++c|     _exp(0,IPU_PORT_NO_IPU_DO)
        ++m|     ipu.send_byte(255) // x-max
        +++l|     #ipu.send_byte.wait_usb_buffer_^3_6
        +++|     // Check buffer has space
        +++c|     _imp(su, IPU_PORT_NO_USB_FLAGS)
        +++c|     _and(su, 1)
        +++c|     _jump(nz,#ipu.send_byte.wait_usb_buffer_^3_6)
        +++|     // Write byte
        +++c|     _exp(255,IPU_PORT_NO_IPU_DO)
        ++m|     ipu.send_byte(255) // y-max
        +++l|     #ipu.send_byte.wait_usb_buffer_^3_7
        +++|     // Check buffer has space
        +++c|     _imp(su, IPU_PORT_NO_USB_FLAGS)
        +++c|     _and(su, 1)
        +++c|     _jump(nz,#ipu.send_byte.wait_usb_buffer_^3_7)
        +++|     // Write byte
        +++c|     _exp(255,IPU_PORT_NO_IPU_DO)
        ++|     
        ++|     // Set Block Size
        ++c|     _exp(0, IPU_PORT_ADDR) //was0
        ++c|     _exp(1, IPU_PORT_LRX)
        ++c|     _exp(0, IPU_PORT_LRX)
        ++c|     _exp(1, IPU_PORT_LCX)
        ++c|     _exp(0, IPU_PORT_LCX)
        ++|     
        ++|     // Set ADC Delay
        ++| 
        ++c|     _exp(8, IPU_PORT_ADC_DELAY) //For this algo, the critical factor is how well IN matches calibration (which is based on the other readout routine)
        ++|     //Increasing speed destroys calibration at high end
        ++c|     _exp(1, IPU_PORT_RD)
        ++c|     _exp(0, IPU_PORT_ADDR) 
        ++c|     _exp(1, IPU_PORT_LR)
        ++c|     _exp(0, IPU_PORT_LR)
        ++|     
        ++|      // 255 dummy samples to smooth out acquisition
        ++| //     _mov(su,0)
        ++| //     #dummy22
        ++| //         _nop
        ++| //         _call(#_ipu_sw_sample_ana)
        ++| //         _add(su, 1)
        ++| //     _jump(nz, #dummy22)
        ++| //     _nop
        ++|     
        ++|     // whole plane sampling loop
        ++c|     _mov(sy, 0)
        ++l|     #rm_loop_row
        ++c|         _nop
        ++c|          _exp(7, IPU_PORT_ADC_FEAMP)
        ++|         // row address
        ++c|         _exp(sy, IPU_PORT_ADDR) 
        ++c|         _exp(1, IPU_PORT_LR)
        ++c|         _exp(0, IPU_PORT_LR)
        ++|         
        ++|         // column address
        ++c|         _mov(sx, 0)
        ++c|         _exp(sx, IPU_PORT_ADDR) 
        ++|          
        ++c|         _exp(1, IPU_PORT_LC)
        ++| //        _exp(0, IPU_PORT_LC)
        ++c|          _exp(6, IPU_PORT_ADC_FEAMP)
        ++|  
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++|         
        ++l|         #rm_loop_col
        ++c|             _nop
        ++|             
        ++c|             _add(sx, 1)
        ++|             
        ++|             // sample and store in sw
        ++c|             _call(#_ipu_sw_sample_ana)
        ++c|             _nop
        ++|            
        ++|             // column address
        ++c|             _exp(7 , IPU_PORT_ADC_FEAMP) //Set low gain
        ++c|             _exp(sx, IPU_PORT_ADDR)
        ++c|             _exp(6, IPU_PORT_ADC_FEAMP) //Set high gain
        ++|             
        ++|             // send result
        ++m|             ipu.send_byte(sw)
        +++l|     #ipu.send_byte.wait_usb_buffer_^3_8
        +++|     // Check buffer has space
        +++c|     _imp(su, IPU_PORT_NO_USB_FLAGS)
        +++c|     _and(su, 1)
        +++c|     _jump(nz,#ipu.send_byte.wait_usb_buffer_^3_8)
        +++|     // Write byte
        +++c|     _exp(ipuvar[13],IPU_PORT_NO_IPU_DO)
        ++|              
        ++c|             _cmp(sx,0)
        ++c|         _jump(nz, #rm_loop_col)
        ++c|         _nop
        ++|         
        ++c|         _add(sy, 1)
        ++c|     _jump(nz, #rm_loop_row)
        ++c|     _nop
        ++|     
        ++|     
        ++l|     #rm_quit
        ++|     
        ++|     // clocks back to normal (9MHz at 90MHz clk)
        ++c|     _exp(8, IPU_PORT_CLK_SWITCH)
        ++c|     _exp(0, IPU_PORT_RD)
        ++|     //N.B. Placing the clocks here MIGHT cause some deleterious effects since clocks
        ++|     //will run in spite of potentially no new ICWs being issued.... But should be short in most circumstances.
        ++c| _ret
        ++| 
        ++p| !endif
        ++| 
        ++| //------------------------------------------------------------------------------
        ++| 
        ++p| !if(USE_CALL_USB_DOUT_256_ROW_MAJOR, ==, 1)
        ++| 
        ++l| #_ipu_sa_dout_usb
        ++|  //   _exp(255, IPU_PORT_CLK_SWITCH)
        ++|     
        ++| 
        ++c|      _exp(8, IPU_PORT_CLK_SWITCH)
        ++| //     _nop
        ++|     
        ++c|     _exp(0, IPU_PORT_B)
        ++c|     keep
        ++c|     set('pgdb' 'dig8' 'pgdbobus' 'sin') //get the command required sent whenever I turn clocks on
        ++|     
        ++c|     _exp(255, IPU_PORT_CLK_SWITCH)
        ++|     //_nop
        ++c|     _exp(0, IPU_PORT_RD) //turn on clocks
        ++m|     ipu.send_byte(PCKT_START)
        +++l|     #ipu.send_byte.wait_usb_buffer_^3_9
        +++|     // Check buffer has space
        +++c|     _imp(su, IPU_PORT_NO_USB_FLAGS)
        +++c|     _and(su, 1)
        +++c|     _jump(nz,#ipu.send_byte.wait_usb_buffer_^3_9)
        +++|     // Write byte
        +++c|     _exp(85,IPU_PORT_NO_IPU_DO)
        ++m|     ipu.send_byte(8) // packet id for digital frame
        +++l|     #ipu.send_byte.wait_usb_buffer_^3_10
        +++|     // Check buffer has space
        +++c|     _imp(su, IPU_PORT_NO_USB_FLAGS)
        +++c|     _and(su, 1)
        +++c|     _jump(nz,#ipu.send_byte.wait_usb_buffer_^3_10)
        +++|     // Write byte
        +++c|     _exp(8,IPU_PORT_NO_IPU_DO)
        ++m|     ipu.send_byte(0) // x-min
        +++l|     #ipu.send_byte.wait_usb_buffer_^3_11
        +++|     // Check buffer has space
        +++c|     _imp(su, IPU_PORT_NO_USB_FLAGS)
        +++c|     _and(su, 1)
        +++c|     _jump(nz,#ipu.send_byte.wait_usb_buffer_^3_11)
        +++|     // Write byte
        +++c|     _exp(0,IPU_PORT_NO_IPU_DO)
        ++m|     ipu.send_byte(0) // y-min
        +++l|     #ipu.send_byte.wait_usb_buffer_^3_12
        +++|     // Check buffer has space
        +++c|     _imp(su, IPU_PORT_NO_USB_FLAGS)
        +++c|     _and(su, 1)
        +++c|     _jump(nz,#ipu.send_byte.wait_usb_buffer_^3_12)
        +++|     // Write byte
        +++c|     _exp(0,IPU_PORT_NO_IPU_DO)
        ++m|     ipu.send_byte(255) // x-max
        +++l|     #ipu.send_byte.wait_usb_buffer_^3_13
        +++|     // Check buffer has space
        +++c|     _imp(su, IPU_PORT_NO_USB_FLAGS)
        +++c|     _and(su, 1)
        +++c|     _jump(nz,#ipu.send_byte.wait_usb_buffer_^3_13)
        +++|     // Write byte
        +++c|     _exp(255,IPU_PORT_NO_IPU_DO)
        ++m|     ipu.send_byte(255) // y-max
        +++l|     #ipu.send_byte.wait_usb_buffer_^3_14
        +++|     // Check buffer has space
        +++c|     _imp(su, IPU_PORT_NO_USB_FLAGS)
        +++c|     _and(su, 1)
        +++c|     _jump(nz,#ipu.send_byte.wait_usb_buffer_^3_14)
        +++|     // Write byte
        +++c|     _exp(255,IPU_PORT_NO_IPU_DO)
        ++|     // Set Block Size
        ++c|     _exp(0, IPU_PORT_ADDR) 
        ++c|     _exp(1, IPU_PORT_LRX)
        ++c|     _exp(0, IPU_PORT_LRX)
        ++c|     _exp(7, IPU_PORT_ADDR) //note that 8 bits are returned at a time
        ++c|     _exp(1, IPU_PORT_LCX)
        ++c|     _exp(0, IPU_PORT_LCX)
        ++|     
        ++c|     _mov(sy, 0)
        ++|     //_exp(sy, IPU_PORT_ADDR) 
        ++l|     #loop_row43
        ++c|         _nop
        ++|         
        ++|         // Set Column address
        ++c|         _exp(sy, IPU_PORT_ADDR)
        ++c|         _exp(1, IPU_PORT_LR)
        ++c|         _exp(0, IPU_PORT_LR)
        ++c|         _mov(sx,0)
        ++c|         _exp(1, IPU_PORT_LC)
        ++| //      _exp(0, IPU_PORT_RD) //turn off clocks
        ++| //      _nop
        ++| //      keep
        ++| //      set('pgdb' 'dig8' 'pgdbobus' 'sin') //moved these commands to the start of the macro
        ++l|         #loop_col4
        ++c|         _nop
        ++|             // Set Row address
        ++c|             _exp(sx, IPU_PORT_ADDR) 
        ++c|             _exp(4, IPU_PORT_CLK_SWITCH) //sensible speed for VC commands
        ++c|             _exp(1, IPU_PORT_RD) //sends the VC command "kept" at start of macro
        ++c|             _exp(255, IPU_PORT_CLK_SWITCH) //high speed for read and send
        ++c|             _imp(sw, 234)
        ++c|             _exp(0, IPU_PORT_RD)    
        ++m|             ipu.send_byte(sw)
        +++l|     #ipu.send_byte.wait_usb_buffer_^3_15
        +++|     // Check buffer has space
        +++c|     _imp(su, IPU_PORT_NO_USB_FLAGS)
        +++c|     _and(su, 1)
        +++c|     _jump(nz,#ipu.send_byte.wait_usb_buffer_^3_15)
        +++|     // Write byte
        +++c|     _exp(ipuvar[13],IPU_PORT_NO_IPU_DO)
        ++|             
        ++c|             _add(sx, 8) //increment by 8
        ++c|         _jump(nz, #loop_col4)
        ++c|         _nop
        ++|         
        ++c|         _add(sy, 1)
        ++c|     _jump(nz, #loop_row43)
        ++c|     _nop 
        ++|     
        ++c|     _exp(0, IPU_PORT_LC) //return LC low
        ++c|     _exp(8, IPU_PORT_CLK_SWITCH)
        ++c|     _exp(0, IPU_PORT_RD)
        ++c| _ret
        ++| 
        ++p| !endif
        ++| 
        ++| //------------------------------------------------------------------------------
        ++| 
        ++p| !if(USE_CALL_SPI_AOUT_ROW_MAJOR, ==, 1)
        ++| 
        ++l| #_ipu_sa_readout_rm_spi
        ++|     
        ++|     // Set Block Size
        ++c|     _exp(0, IPU_PORT_ADDR) //was0
        ++c|     _exp(1, IPU_PORT_LRX)
        ++c|     _exp(0, IPU_PORT_LRX)
        ++c|     _exp(1, IPU_PORT_LCX)
        ++c|     _exp(0, IPU_PORT_LCX)
        ++|     
        ++|     // ADC Delay
        ++c|     _exp(8, IPU_PORT_ADC_DELAY) //For this algo, the critical factor is how well IN matches calibration (which is based on the other readout routine)
        ++|     //Increasing speed destroys calibration at high end
        ++c|     _exp(1, IPU_PORT_RD)
        ++c|     _exp(0, IPU_PORT_ADDR) 
        ++c|     _exp(1, IPU_PORT_LR)
        ++c|     _exp(0, IPU_PORT_LR)
        ++|     
        ++|     // whole plane sampling loop
        ++c|     _mov(sy, 0)
        ++l|     #spi_rm_sz_loop_row
        ++c|         _nop
        ++|         
        ++c|         _exp(7, IPU_PORT_ADC_FEAMP)
        ++|         // row address
        ++c|         _exp(sy, IPU_PORT_ADDR) 
        ++c|         _exp(1, IPU_PORT_LR)
        ++c|         _exp(0, IPU_PORT_LR)
        ++|         
        ++|         // column address
        ++c|         _mov(sx, 0)
        ++c|         _exp(sx, IPU_PORT_ADDR) 
        ++|          
        ++c|         _exp(1, IPU_PORT_LC)
        ++| //        _exp(0, IPU_PORT_LC)
        ++c|         _exp(6, IPU_PORT_ADC_FEAMP)
        ++|  
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++c|         _nop
        ++|         
        ++l|         #spi_rm_sz_loop_col
        ++c|             _nop
        ++|             
        ++c|             _add(sx, sv)
        ++|             
        ++|             // sample and store in sw
        ++c|             _call(#_ipu_sw_sample_ana)
        ++c|             _nop
        ++|            
        ++|             // column address
        ++|             
        ++c|             _exp(7 , IPU_PORT_ADC_FEAMP) //Set low gain
        ++c|             _exp(sx, IPU_PORT_ADDR)
        ++c|             _exp(6, IPU_PORT_ADC_FEAMP) //Set high gain
        ++|             
        ++|             // send result
        ++m|             spi.wait_fifo
        +++l|     #spi.wait_fifo.wait_spi_fifo_^3_16
        +++c|     _imp(su, IPU_PORT_SPI_USB_FLAGS)
        +++c|     _and(su, 4)
        +++c|     _jump(nz,#spi.wait_fifo.wait_spi_fifo_^3_16)
        ++m|             spi.send_byte(sw)
        +++c|     _exp(ipuvar[13],IPU_PORT_NO_IPU_DO)
        ++|             
        ++c|             _cmp(sx,0)
        ++c|         _jump(nz, #spi_rm_sz_loop_col)
        ++c|         _nop
        ++|         
        ++c|         _add(sy, sv)
        ++c|     _jump(nz, #spi_rm_sz_loop_row)
        ++c|     _nop
        ++|     
        ++c| _ret
        ++| 
        ++p| !endif
        ++| 
        ++| //------------------------------------------------------------------------------
        ++| 
        ++p| !if(USE_CALL_SPI_DOUT_ROW_MAJOR, ==, 1)
        ++| 
        ++l| #_ipu_spi_dout
        ++|     // Set Block Size
        ++c|     _exp(0, IPU_PORT_ADDR) 
        ++c|     _exp(1, IPU_PORT_LRX)
        ++c|     _exp(0, IPU_PORT_LRX)
        ++c|     _exp(7, IPU_PORT_ADDR) //note that 8 bits are returned at a time
        ++c|     _exp(1, IPU_PORT_LCX)
        ++c|     _exp(0, IPU_PORT_LCX)
        ++|     
        ++c|     _mov(sy, 0)
        ++|     //_exp(sy, IPU_PORT_ADDR) 
        ++l|     #_ipu_spi_dout_loop_y
        ++c|         _nop
        ++|         
        ++|         // Set Column address
        ++c|         _exp(sy, IPU_PORT_ADDR)
        ++c|         _exp(1, IPU_PORT_LR)
        ++c|         _exp(0, IPU_PORT_LR)
        ++c|         _mov(sx,0)
        ++c|         _exp(1, IPU_PORT_LC)
        ++|         
        ++l|         #_ipu_spi_dout_loop_x
        ++c|         _nop
        ++|             // Set Row address
        ++c|             _exp(sx, IPU_PORT_ADDR) 
        ++c|             _exp(4, IPU_PORT_CLK_SWITCH) //sensible speed for VC commands
        ++c|             _exp(1, IPU_PORT_RD) //sends the VC command "kept" at start of macro
        ++c|             _exp(255, IPU_PORT_CLK_SWITCH) //high speed for read and send
        ++c|             _imp(sw, 234)
        ++c|             _exp(0, IPU_PORT_RD)
        ++|             
        ++|             // send result
        ++m|             spi.wait_fifo
        +++l|     #spi.wait_fifo.wait_spi_fifo_^3_18
        +++c|     _imp(su, IPU_PORT_SPI_USB_FLAGS)
        +++c|     _and(su, 4)
        +++c|     _jump(nz,#spi.wait_fifo.wait_spi_fifo_^3_18)
        ++m|             spi.send_byte(sw)
        +++c|     _exp(ipuvar[13],IPU_PORT_NO_IPU_DO)
        ++|             
        ++c|             _add(sx, 8) //increment by 8
        ++c|         _jump(nz, #_ipu_spi_dout_loop_x)
        ++c|         _nop
        ++|         
        ++c|         _add(sy, 1)
        ++c|     _jump(nz, #_ipu_spi_dout_loop_y)
        ++c|     _nop 
        ++|     
        ++c|     _exp(0, IPU_PORT_LC) //return LC low
        ++|     
        ++c| _ret
        ++| 
        ++p| !endif
        ++| 
        +| 
        +| //------------------------------------------------------------------------------
        +| 
        +l| #program_entry
        +| 
        +| // Some magic!
        +c| _nop
        +c| _mov(s1,0)
        +| 
        +m| ipu.config_clocks
        ++c|     _imp(su,3)
        ++c|     _exp(su,IPU_PORT_RISE_C1)
        ++c|     _imp(su,4)
        ++c|     _exp(su,IPU_PORT_FALL_C1)
        ++c|     _imp(su,5)
        ++c|     _exp(su,IPU_PORT_RISE_C2)
        ++c|     _imp(su,6)
        ++c|     _exp(su,IPU_PORT_FALL_C2)
        ++c|     _imp(su,7)
        ++c|     _exp(su,IPU_PORT_RISE_C3)
        ++c|     _imp(su,8)
        ++c|     _exp(su,IPU_PORT_FALL_C3)
        ++c|     _imp(su,9)
        ++c|     _exp(su,IPU_PORT_RISE_C4)
        ++c|     _imp(su,10)
        ++c|     _exp(su,IPU_PORT_FALL_C4)
        ++| 
        ++c|     _imp(su,11)
        ++c|     _exp(su,IPU_PORT_FRAME_CNT_B0)
        ++c|     _imp(su,12)
        ++c|     _exp(su,IPU_PORT_FRAME_CNT_B1)
        ++c|     _imp(su,13)
        ++c|     _exp(su,IPU_PORT_FRAME_CNT_B2)
        +m| ipu.analog_calibrate
        ++c| 	_nop
        ++c| _exp(19, IPU_PORT_POWER) //power up Analog
        ++c| _nop
        ++c|     _nop
        ++c|     _exp(7 , IPU_PORT_ADC_FEAMP) //Power up op-amps
        ++c|     _exp(32, IPU_PORT_CLK_SWITCH)//really slow clock
        ++c|     _nop
        ++c|     _exp(19, IPU_PORT_POWER) //power up Analog
        ++c|     _exp(27, IPU_PORT_POWER) //Enable scamp
        ++c|     _exp(25, IPU_PORT_POWER) //Unsnooze smps
        ++c|     _call(#_ipu_st_delay)
        ++c|     _nop
        ++c|     _exp(57, IPU_PORT_POWER) //Power up DAC opamp
        ++c|     _exp(121, IPU_PORT_POWER) //Power up DAC 
        ++c|     _exp(249, IPU_PORT_POWER) //Unclr DAC
        ++c|     _exp(248, IPU_PORT_POWER) //POwer up ADC
        ++c|     _call(#_ipu_st_delay)
        ++c|     _nop
        ++c|     _call(#_ipu_st_delay)
        ++c|     _nop
        ++c|     _call(#_ipu_st_delay)
        ++c|     _nop
        ++c|     _call(#_ipu_st_delay)
        ++c|     _nop
        ++c|     _exp(252, IPU_PORT_POWER) //POwer up VDDA
        ++c|     _exp(32, IPU_PORT_CLK_SWITCH)//really slow clock
        ++c|     _nop
        ++| 
        ++|     
        ++c|     _nop
        ++| 
        ++c| 	_exp(4, IPU_PORT_CLK_SWITCH) //returns clocks back to normal (9MHz at 90MHz clk)
        ++c| 	_nop
        ++c| 	_exp(0,IPU_PORT_calib)
        ++c| 	_exp(0, IPU_PORT_RD)
        ++c| 	_exp(8, IPU_PORT_DACS) //Vdiv2
        ++c| 	_exp(70, IPU_PORT_B) //Vdiv2
        ++c| 	_exp(9, IPU_PORT_DACS)//Vres
        ++c| 	_exp(79, IPU_PORT_B)//Vres //75 1st system, 79 second
        ++c| 	_exp(10, IPU_PORT_DACS) //Vdiff
        ++c| 	_exp(211, IPU_PORT_B)//Vdiff
        ++c| 	_exp(11, IPU_PORT_DACS)//vxc
        ++c| 	_exp(158, IPU_PORT_B)//vxc //was 158 for other boxes
        ++c| 	_exp(12, IPU_PORT_DACS) //pbias
        ++c| 	_exp(211, IPU_PORT_B)//pbias
        ++c| 	_exp(13, IPU_PORT_DACS)//vdiv1
        ++c| 	_exp(67, IPU_PORT_B)//vdiv1
        ++c| 	_exp(14, IPU_PORT_DACS) //cbias
        ++c| 	_exp(63, IPU_PORT_B)//cbias
        ++c| 	_exp(15, IPU_PORT_DACS)//cbus
        ++c| 	_exp(70, IPU_PORT_B)//cbus
        ++c| 		_exp(16, IPU_PORT_DACS) //ADCrefhi
        ++c| 		_exp(234, IPU_PORT_B)//ADCrefhi
        ++c| 	_exp(17, IPU_PORT_DACS)//1VrefAmpA
        ++c| 	_exp(71, IPU_PORT_B)//1VrefAmpA //was 71
        ++c| 	_exp(18, IPU_PORT_DACS) //Secampoffset
        ++c| 	_exp(122, IPU_PORT_B)//Secampoffset 105 first board! //102 and 248 first board last 102
        ++c| 	_exp(248, IPU_PORT_DACsLSBs) //Increase to increase A= ; out A return
        ++c| 	_exp(19, IPU_PORT_DACS)//1VrefAMPB
        ++c| 	_exp(68, IPU_PORT_B)//1VrefAMPB //was72
        ++c| 	_exp(0, IPU_PORT_DACsLSBs)
        ++c| 	_exp(20, IPU_PORT_DACS) //ADCreflo
        ++c| 	_exp(23, IPU_PORT_B)//ADCreflo
        ++c| 	_exp(21, IPU_PORT_DACS)//VDACbias
        ++c| 	_exp(94, IPU_PORT_B)//VDACbias
        ++c| 	_exp(22, IPU_PORT_DACS) //Vdacref
        ++c| 	_exp(164, IPU_PORT_B)//Vdacref
        ++c| 	_exp(23, IPU_PORT_DACS) //empty
        ++c| 	_exp(117, IPU_PORT_B)//empty
        ++c| 	_exp(0, IPU_PORT_DACS) //set for ordinary portB commands
        ++| //end set voltages
        ++c| 	    _call(#_ipu_st_delay)
        ++c|     _nop
        ++c|     _call(#_ipu_st_delay)
        ++c|     _nop
        +m| SetCentres
        ++c| _nop
        ++c| 	_exp(8, IPU_PORT_CLK_SWITCH) //returns clocks back to normal (9MHz at 90MHz clk)
        ++c| 	_exp(0, IPU_PORT_RD)
        ++c| 	_nop
        ++| 	
        ++c| 	 set('wrf')
        ++c| 	 all
        ++c| 	_mov(s6,102)// Start at 106
        ++c| 	_exp(s6, IPU_PORT_B)
        ++c| 	_exp(18, IPU_PORT_DACS) //Setting SecAmpOffset
        ++c| 	_exp(s6, IPU_PORT_B)
        ++c| 	_call(#_ipu_st_delay)
        ++c| 	_nop
        ++c| 	_call(#_ipu_st_delay)
        ++c| 	_nop
        ++c| 	_call(#_ipu_st_delay)
        ++c| 	_nop
        ++c| 	_call(#_ipu_st_delay)
        ++c| 	_nop
        ++c| 		_call(#_ipu_st_delay)
        ++c| 	_nop
        ++c| 		_call(#_ipu_st_delay)
        ++c| 	_nop
        ++c| 		_call(#_ipu_st_delay) //Delay insertion turns out to be somewhat critical...
        ++c| 	_nop
        ++c| 			_call(#_ipu_st_delay)
        ++c| 	_nop
        ++c| 	_call(#_ipu_st_delay)
        ++c| 	_nop
        ++| 
        ++l| 	 #CcycleMSBB
        ++c| 	 _nop
        ++c| 	 _mov(s5,240) //Start at 0. 240 is "zero" when you look at the 4 LSBs. A bug in hardware perhaps
        ++l| 	 #CcycleLSBB
        ++c| 	 _nop
        ++c| 	 _exp(6,248)
        ++c| 	 _exp(8, IPU_PORT_CLK_SWITCH) 
        ++c| 	 _exp(0, IPU_PORT_RD)
        ++c| 	_nop
        ++c| 	_call(#_ipu_st_delay)
        ++c| 	_nop
        ++c| 	 _exp(s6, IPU_PORT_B)
        ++c| 	 _nop
        ++c| 	 _exp(s5, IPU_PORT_DACsLSBs)
        ++c| 	 _nop
        ++c| 		A = 
        ++c| 	 	keep 
        ++c| 	set('SEL1' 'ana' ) 
        ++c|  	_call(#Calibreadout)
        ++c| 	 _nop
        ++| 	 
        ++c| 	  _nop
        ++c| 	_add(sw,132)//subtract 131 from ReadData Set at 131 since it appears to work.
        ++c| 	_jump(c, #FoundCentre)//if a carry occurs it means 128 reached
        ++c| 	_nop
        ++c| 	 _add(s5,1)
        ++c| 	 _jump(nz, #CcycleLSBB)
        ++c| 	 _nop
        ++c| 	 _add(s6,1)
        ++c| 	 _jump(nz, #CcycleMSBB)
        ++c| 	  _nop
        ++l| 	  #FoundCentre
        ++c| 	  _nop
        ++| 	  
        ++| 	//_exp(18, IPU_PORT_DACS) //Setting SecAmpOffset
        ++| //	_exp(62, IPU_PORT_B)
        ++| 	//	_exp(18, IPU_PORT_DACS) //Setting SecAmpOffset
        ++| // 	_nop
        ++c|  	 _exp(23, IPU_PORT_DACS) //empty Adding this seems to make it work better (reason?)
        ++c|  	 _exp(0, IPU_PORT_DACS) 
        ++c|  	 _nop
        +m| Calib_IN_Diff
        ++c| 	_nop
        ++c| 	_mov(s1, 8)  //returns clocks back to normal (9MHz at 90MHz clk)
        ++| //Now starting the IN calibration routine	
        ++| //Bit added for running at 10MHz
        ++c| _cmp(s1,8)
        ++c| _jump(z, #skipclocks)
        ++c| _exp(0,IPU_PORT_RISE_C4)
        ++c| _exp(10,IPU_PORT_FALL_C4)
        ++c| _exp(0,IPU_PORT_RISE_C1)
        ++c| _exp(6,IPU_PORT_FALL_C1)
        ++c| _exp(6,IPU_PORT_RISE_C2)
        ++c| _exp(10,IPU_PORT_FALL_C2) //6 looks okay!
        ++l| #skipclocks
        ++c| _nop
        ++| //End of bit added for running at 10MHz		
        ++c| 	_exp(s1, IPU_PORT_CLK_SWITCH)
        ++c| 	_nop
        ++c| 	_exp(0, IPU_PORT_DACS) 
        ++c| 	all
        ++c| 	 _exp(0, IPU_PORT_ADDR) 
        ++c| 	_exp(1, IPU_PORT_LRX)
        ++c| 	_exp(0, IPU_PORT_LRX)
        ++c| 	_exp(1, IPU_PORT_LCX)
        ++c| 	_exp(0, IPU_PORT_LCX)
        ++| 	
        ++| 	// Set ADC Delay
        ++| 
        ++c| 	_exp(8, IPU_PORT_ADC_DELAY)
        ++c| 	_exp(63, IPU_PORT_ADDR) //use pixel at (63,63)
        ++c| 	_exp(1, IPU_PORT_LR)
        ++| 	//_exp(0, IPU_PORT_LR)
        ++c| 	_exp(1, IPU_PORT_LC)
        ++| 	//_exp(0, IPU_PORT_LC)
        ++c| 	_exp(6, 248)
        ++| 
        ++c|  	_exp(1,IPU_PORT_calib) //OK. Now we're calibrating
        ++|  	
        ++|  	//First find the IN corresponding to the 128 position so can get the calibration right
        ++c|  	_mov(s6, 255)
        ++c|  	_exp(15, IPU_PORT_DACsLSBs)
        ++l|  	#Findposition
        ++c|  	_nop
        ++c|  	_sub(s6, 1)
        ++c|  	_exp(0, IPU_PORT_RD)
        ++c|  	_exp(s6, IPU_PORT_B)
        ++c|  	 F =
        ++c|  	_nop
        ++c|  	_nop
        ++c|  	_nop
        ++c|  	F = IN
        ++c|  	keep //not really needed since clocks turned off afterwards
        ++c| 	set( 'SEL7' 'ana' )
        ++c| 	_call(#Calibreadout)
        ++c| 	_nop
        ++c| 	_exp(s1, IPU_PORT_CLK_SWITCH)
        ++c|  	_exp(0, IPU_PORT_RD) 
        ++c| 	_nop
        ++c| 	_add(sw,128)//Add 128.... so will jump and repeat if not over 128.
        ++c| 	_jump(nc,#Findposition)
        ++c| 	_nop
        ++c| 	_mov(s4, s6) //s4 = s6 
        ++| 	//So saved the 128 value in s4
        ++| 	//Now decrementing IN values from 255
        ++c| 	_mov(s6, 255)
        ++c| 	 _exp(s4, IPU_PORT_B)
        ++c|  	_mov(s9,0) //Zero will be first element of table to be filled
        ++c|   	_call(#_ipu_st_delay)//a delay to allow the pre-filling of zero data into array
        ++c| 	_nop
        ++c| 	_mov(s6,255)// Start at highest B values=> lowest Vin => highest IN source=> lowest A values
        ++l| 	 #cycleMSBB
        ++c| 	 _nop
        ++c| 	 _mov(s5,255) //was15. The 3 LSBs seem to get stuck periodically. THe 255 start works around the D1-D2. But D0 requires that it is not used
        ++| 	 //since it sticks at 1. So decrement by 2.
        ++l| 	 #cycleLSBB
        ++c| 	 _nop
        ++c| 	 _exp(s5, IPU_PORT_DACsLSBs)
        ++| // 	
        ++c| 	 _exp(s4, IPU_PORT_B)// I resend 128 every time since want to keep transitions the same. 
        ++c| 	 A F = //	
        ++| 	// set('sin')
        ++| 	// _nop //UNDELETE this nop if trying to go at 9MHz	
        ++c| 	_nop //This nop is IMPORTANT. It matches the Set, Sin, import,set, A =IN of the IN macro. It gets timing the same - replaces the missing import that isnt needed here
        ++c| 	F = IN
        ++c| 	_exp(s6, IPU_PORT_B) //Now exporting the new DAC value
        ++| 	// _nop //UNDELETE this nop if trying to go at 9MHz
        ++c| 	 A =  F IN
        ++c| 	 keep //not really needed since clocks turned off afterwards
        ++c| 	set( 'SEL1' 'ana' )
        ++c| 	_call(#Calibreadout)
        ++c| 	 _nop
        ++c| 	_sub(sw,s9)//subtract ReadData by s9 
        ++c| 	_jump(c, #nostoreB)//if a carry occurs it means new value is lower than previous value already stored
        ++c| 	_nop
        ++c| 	_exp(3,IPU_PORT_calib)
        ++c| 	_nop
        ++c| 	_nop
        ++c| 	_exp(1,IPU_PORT_calib)
        ++c| 	_cmp(s9,255) 
        ++c| 	_jump(z, #endB)//if the system has reached the match value 255, then the B-ramp cuts out and ends
        ++c| 	_nop
        ++c| 	_add(s9,1)//add 1 to s9 for the next mem to be filled
        ++l| 	#nostoreB
        ++c| 	_nop
        ++c| 	_exp(s1, IPU_PORT_CLK_SWITCH)
        ++c|  	_exp(0, IPU_PORT_RD) //gotta take read lo turn ordinary clocks on
        ++c| 	 _exp(s4, IPU_PORT_B) //Centres the IPU port B. Can only be done here since B value is IPU imported to store in calib file
        ++c| 	 _nop
        ++c| 	 _sub(s5,2)//CAHNGE BACK TO 1 if get LSB working
        ++c| 	 _cmp(s5,241)
        ++c| 	 _jump(nz, #cycleLSBB)
        ++c| 	 _nop
        ++c| 	 _sub(s6,1)
        ++c| 	 _jump(nz, #cycleMSBB)
        ++c| 	  _nop
        ++l| 	  #endB
        ++c| 	  _nop
        ++c| 	 _exp(0,IPU_PORT_calib)//turn calib off
        ++c| 	 _nop
        +| 
        +| 
        +| 
        +| 
        | 
        | //////////////////////////////////////////////////////////////////
        m| ipu.reset_loop_counter
        +c|     _exp(0,IPU_PORT_LOOPC_0)
        +c|     _exp(0,IPU_PORT_LOOPC_1)
        +c|     _exp(0,IPU_PORT_LOOPC_2)
        +c|     _exp(0,IPU_PORT_LOOPC_3)
        m| spi.reset
        +c|     _exp(4,253)
        +c|     _exp(0,253)
        | 
        m| spi.set_transfer_size(20)
        +m|     spi.set_transfer_size(20,0)
        ++|     
        ++c|     _exp(255, IPU_PORT_CLK_SWITCH)
        ++c|     _nop
        ++|     
        ++m|     spi.begin
        +++c|     _exp(1, 253)
        ++m|     spi.send_header_bytes(SPI_PACKET_TYPE_COMMAND,0x02,20,0)
        +++c|     _mov(sv,3)
        +++c|     _add(sv,0x02)
        +++c|     _add(sv,20)
        +++c|     _add(sv,0)
        +++m|     spi.send_byte(SPI_SIGNATURE_BYTE_0)
        ++++c|     _exp(0x20,IPU_PORT_NO_IPU_DO)
        +++m|     spi.send_byte(SPI_SIGNATURE_BYTE_1)
        ++++c|     _exp(0x16,IPU_PORT_NO_IPU_DO)
        +++m|     spi.send_byte(SPI_SIGNATURE_BYTE_2)
        ++++c|     _exp(0xAA,IPU_PORT_NO_IPU_DO)
        +++m|     spi.send_byte(3)// packet type
        ++++c|     _exp(3,IPU_PORT_NO_IPU_DO)
        +++m|     spi.send_byte(0x02)// payload size
        ++++c|     _exp(0x02,IPU_PORT_NO_IPU_DO)
        +++m|     spi.send_byte(20)
        ++++c|     _exp(20,IPU_PORT_NO_IPU_DO)
        +++m|     spi.send_byte(0)
        ++++c|     _exp(0,IPU_PORT_NO_IPU_DO)
        +++m|     spi.send_byte(sv)// header checksum
        ++++c|     _exp(ipuvar[14],IPU_PORT_NO_IPU_DO)
        ++m|     spi.end
        +++c|     _exp(1, 246)
        +++c|     _exp(0, 246)
        +++c|     _nop
        +++c|     _exp(0, 253)
        ++|     
        ++c|     _exp(8, IPU_PORT_CLK_SWITCH)
        ++c|     _nop
        ++|     
        | //////////////////////////////////////////////////////////////////
        | 
        l| #frame_loop
        |    
        |     // use double frame trigger to maintain the exposure time
        | //     ipu.wait_frame_trigger
        | //     rpix
        |    
        |     //ipu.wait_frame_trigger
        |     //rpix()
        |     
        m|     ipu.delay_5ms
        +c|     _mov(su,100)
        +c|     _call(#_ipu_su_delay_50us)
        +c|     _nop
        m| 	ipu.delay_5ms
        +c|     _mov(su,100)
        +c|     _call(#_ipu_su_delay_50us)
        +c|     _nop
        | 	
        m|     rpix(B,C)
        +m|     pe.rpix(ar[B],ar[C])
        ++c|     ar[B] = PIX
        ++c|     F = PIX
        ++c|     respix
        ++c|     nop
        ++c|     ar[C] = load(ar[B] F PIX)
        ++c|     ar[B] = load(F PIX)
        |     
        |     ////////////////////////////////////
        |    
        m|     s0 = usb.slider(slider_1)
        +c|     su = host_slider(slider_1)
        +c|     _mov(ipuvar[0],su)
        +c|     _cmp(ipuvar[0],0)
        m|     E = in(s0)
        +m|     ar[E] = pe.in(ipuvar[0])
        ++c|     _mov(su,ipuvar[0])
        ++c|     _exp(128, IPU_PORT_B)// I resend this every time since oughta keep transitions the same. 
        ++c|      set('sin') //drags the bus to the IN level.
        ++c|     _add(su,128)
        ++c|     F = IN
        ++c|     _exp(su, IPU_PORT_B)
        ++c|     ar[E] = F IN
        m|     D = sub(C,E)
        +m|     ar[D] = pe.sub(ar[C],ar[E])
        ++c|     F = ar[C]
        ++c|     ar[D] = load(F ar[E])
        c|     where(D)
        c|         R5 = FLAG
        c|     all
        |     
        |     ////////////////////////////////////
        |     
        | //     usb.dout(R5,window_2)
        | //     all
        |     
        |     ////////////////////////////////////
        |     
        |     //FLAG BOUNDARIES OF THE IMAGE TO USE AS FLOODING SOURCE
        c|     R7 = 0
        m|     R10 = ipu.pixel_select(0,0,0,255)
        +c|     _mov(sy,0)
        +c|     _mov(sx,0)
        +c|     _mov(su,0)
        +c|     _mov(sv,255)
        +c|     _call(#_ipu_sa_pixel_select)
        +c|     _nop
        +c|     dr[R10] = load(R0)
        m|     R11 = ipu.pixel_select(255,0,0,255)
        +c|     _mov(sy,0)
        +c|     _mov(sx,255)
        +c|     _mov(su,0)
        +c|     _mov(sv,255)
        +c|     _call(#_ipu_sa_pixel_select)
        +c|     _nop
        +c|     dr[R11] = load(R0)
        m|    	R7 = or(R10,R11)
        +m|     dr[R7] = pe.or(dr[R10],dr[R11])
        ++c|     dr[R7] = load(dr[R10],dr[R11])
        m|    	R10 = ipu.pixel_select(0,0,255,0)
        +c|     _mov(sy,0)
        +c|     _mov(sx,0)
        +c|     _mov(su,255)
        +c|     _mov(sv,0)
        +c|     _call(#_ipu_sa_pixel_select)
        +c|     _nop
        +c|     dr[R10] = load(R0)
        m|  	R11 = or(R10,R7)
        +m|     dr[R11] = pe.or(dr[R10],dr[R7])
        ++c|     dr[R11] = load(dr[R10],dr[R7])
        m|  	R10 = ipu.pixel_select(0,255,255,0)
        +c|     _mov(sy,255)
        +c|     _mov(sx,0)
        +c|     _mov(su,255)
        +c|     _mov(sv,0)
        +c|     _call(#_ipu_sa_pixel_select)
        +c|     _nop
        +c|     dr[R10] = load(R0)
        m|    	R7 = or(R10,R11)
        +m|     dr[R7] = pe.or(dr[R10],dr[R11])
        ++c|     dr[R7] = load(dr[R10],dr[R11])
        |    	
        |    	////////////////////////////////////
        |     
        |    	
        c|     R10 = R5
        c|     R5 = not(R10)
        m|     s5 = usb.slider(slider_2)
        +c|     su = host_slider(slider_2)
        +c|     _mov(ipuvar[5],su)
        +c|     _cmp(ipuvar[5],0)
        l|     #flooding_loop
        c|     _nop
        |    
        m| 	    R10 = pro.flood_from_source(R5,R7)
        +c|     _exp(4, IPU_PORT_CLK_SWITCH)
        +c|     _nop
        +c|     R0 = 1
        +c|     R1 = 1
        +c|     R2 = 1
        +c|     R3 = 1
        +c|     R4 = 1 //This should be needed to load R12 but works without
        +c|     R12 = dr[R7]
        +c|     R0 = dr[R5] //loading flag from my hole image
        +c|     set('RR12' 'plrb' 'bit' 'bitmode') //discharge plwb, except for start pixel
        +c|     _exp(4, IPU_PORT_CLK_SWITCH)
        +c|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' ) //i.e. pupd=0. Boundary is zero.
        +c|     _exp(0,IPU_PORT_RISE_C2)
        +c|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' )
        +c|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' )
        +c|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' )
        +c|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' )
        +|     //set('LR12' 'RR12' 'rid' 'nb' 'float' 'setf') //setting flag for next instr.
        +c|     _exp(4,IPU_PORT_RISE_C2)
        +c|     _exp(8, IPU_PORT_CLK_SWITCH)
        +c|     _exp(0, IPU_PORT_RD)
        +c|     dr[R10] = R12
        m| 	    R11 = pro.flood_from_source(R5,R10)
        +c|     _exp(4, IPU_PORT_CLK_SWITCH)
        +c|     _nop
        +c|     R0 = 1
        +c|     R1 = 1
        +c|     R2 = 1
        +c|     R3 = 1
        +c|     R4 = 1 //This should be needed to load R12 but works without
        +c|     R12 = dr[R10]
        +c|     R0 = dr[R5] //loading flag from my hole image
        +c|     set('RR12' 'plrb' 'bit' 'bitmode') //discharge plwb, except for start pixel
        +c|     _exp(4, IPU_PORT_CLK_SWITCH)
        +c|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' ) //i.e. pupd=0. Boundary is zero.
        +c|     _exp(0,IPU_PORT_RISE_C2)
        +c|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' )
        +c|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' )
        +c|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' )
        +c|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' )
        +|     //set('LR12' 'RR12' 'rid' 'nb' 'float' 'setf') //setting flag for next instr.
        +c|     _exp(4,IPU_PORT_RISE_C2)
        +c|     _exp(8, IPU_PORT_CLK_SWITCH)
        +c|     _exp(0, IPU_PORT_RD)
        +c|     dr[R11] = R12
        m| 	    R10 = pro.flood_from_source(R5,R11)
        +c|     _exp(4, IPU_PORT_CLK_SWITCH)
        +c|     _nop
        +c|     R0 = 1
        +c|     R1 = 1
        +c|     R2 = 1
        +c|     R3 = 1
        +c|     R4 = 1 //This should be needed to load R12 but works without
        +c|     R12 = dr[R11]
        +c|     R0 = dr[R5] //loading flag from my hole image
        +c|     set('RR12' 'plrb' 'bit' 'bitmode') //discharge plwb, except for start pixel
        +c|     _exp(4, IPU_PORT_CLK_SWITCH)
        +c|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' ) //i.e. pupd=0. Boundary is zero.
        +c|     _exp(0,IPU_PORT_RISE_C2)
        +c|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' )
        +c|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' )
        +c|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' )
        +c|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' )
        +|     //set('LR12' 'RR12' 'rid' 'nb' 'float' 'setf') //setting flag for next instr.
        +c|     _exp(4,IPU_PORT_RISE_C2)
        +c|     _exp(8, IPU_PORT_CLK_SWITCH)
        +c|     _exp(0, IPU_PORT_RD)
        +c|     dr[R10] = R12
        m| 	    R11 = pro.flood_from_source(R5,R10)
        +c|     _exp(4, IPU_PORT_CLK_SWITCH)
        +c|     _nop
        +c|     R0 = 1
        +c|     R1 = 1
        +c|     R2 = 1
        +c|     R3 = 1
        +c|     R4 = 1 //This should be needed to load R12 but works without
        +c|     R12 = dr[R10]
        +c|     R0 = dr[R5] //loading flag from my hole image
        +c|     set('RR12' 'plrb' 'bit' 'bitmode') //discharge plwb, except for start pixel
        +c|     _exp(4, IPU_PORT_CLK_SWITCH)
        +c|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' ) //i.e. pupd=0. Boundary is zero.
        +c|     _exp(0,IPU_PORT_RISE_C2)
        +c|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' )
        +c|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' )
        +c|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' )
        +c|     set('LR12' 'RR12' 'rid' 'nb' 'plrb' 'float' )
        +|     //set('LR12' 'RR12' 'rid' 'nb' 'float' 'setf') //setting flag for next instr.
        +c|     _exp(4,IPU_PORT_RISE_C2)
        +c|     _exp(8, IPU_PORT_CLK_SWITCH)
        +c|     _exp(0, IPU_PORT_RD)
        +c|     dr[R11] = R12
        | 	   
        c| 	    R7 = R11
        | 	   
        c| 	    R10 = not(R11)
        m| 	    R9 = and(R5,R10)
        +m|     dr[R9] = pe.and(dr[R5],dr[R10])
        ++c|     dr[R9] = not(dr[R5])
        ++c|     dr[R5] = not(dr[R10])
        ++c|     R0 = load(dr[R9],dr[R5])
        ++c|     dr[R5] = not(dr[R9])
        ++c|     dr[R9] = not(R0)
        c| 	    R5 = not(R9)
        |    
        c|      _sub(s5,1)
        c|      _jump(nc,#flooding_loop)
        |    
        |     ////////////////////////////////////
        |     
        |    
        c|     R7 = not(R5)
        m|     spi.begin
        +c|     _exp(1, 253)
        m|     spi.scan_target(R7)
        +|     
        +|     
        +c|     _exp(255, IPU_PORT_CLK_SWITCH)
        +c|     _exp(1, IPU_PORT_RD)
        +|     
        +|     // spi header
        +m|     spi.send_byte(SPI_SIGNATURE_BYTE_0)
        ++c|     _exp(0x20,IPU_PORT_NO_IPU_DO)
        +m|     spi.send_byte(SPI_SIGNATURE_BYTE_1)
        ++c|     _exp(0x16,IPU_PORT_NO_IPU_DO)
        +m|     spi.send_byte(SPI_SIGNATURE_BYTE_2)
        ++c|     _exp(0xAA,IPU_PORT_NO_IPU_DO)
        +m|     spi.send_byte(SPI_PACKET_TYPE_STANDARD_TARGET)// 7
        ++c|     _exp(7,IPU_PORT_NO_IPU_DO)
        +m|     spi.send_byte(8)// payload size
        ++c|     _exp(8,IPU_PORT_NO_IPU_DO)
        +m|     spi.send_byte(0)
        ++c|     _exp(0,IPU_PORT_NO_IPU_DO)
        +m|     spi.send_byte(0)
        ++c|     _exp(0,IPU_PORT_NO_IPU_DO)
        +m|     spi.send_byte(15)// header checksum
        ++c|     _exp(15,IPU_PORT_NO_IPU_DO)
        +|     
        +|     // uint32 payload: loop counter
        +c|     _imp(sv,IPU_PORT_LOOPC_0)
        +m|     spi.send_byte(sv)
        ++c|     _exp(ipuvar[14],IPU_PORT_NO_IPU_DO)
        +c|     _imp(sv,IPU_PORT_LOOPC_1)
        +m|     spi.send_byte(sv)
        ++c|     _exp(ipuvar[14],IPU_PORT_NO_IPU_DO)
        +c|     _imp(sv,IPU_PORT_LOOPC_2)
        +m|     spi.send_byte(sv)
        ++c|     _exp(ipuvar[14],IPU_PORT_NO_IPU_DO)
        +c|     _imp(sv,IPU_PORT_LOOPC_3)
        +m|     spi.send_byte(sv)
        ++c|     _exp(ipuvar[14],IPU_PORT_NO_IPU_DO)
        +|     
        +|     // do the scanning
        +|     
        +c|     _exp(255, IPU_PORT_ADDR) //search all rows
        +c|     _exp(1, IPU_PORT_LRX)
        +c|     _exp(0, IPU_PORT_LRX)
        +c|     _exp(255, IPU_PORT_ADDR) //search all col
        +c|     _exp(1, IPU_PORT_LCX)
        +c|     _exp(0, IPU_PORT_LCX)
        +|     
        +c|     _exp(0, IPU_PORT_ADDR)
        +c|     _exp(1, IPU_PORT_LC)
        +c|     _exp(0, IPU_PORT_LC)
        +c|     _exp(1, IPU_PORT_LR)
        +c|     _exp(0, IPU_PORT_LR)
        +|     
        +c|     _exp(8, IPU_PORT_CLK_SWITCH)
        +c|     _nop
        +c|     _exp(0, IPU_PORT_RD)
        +c|     _nop
        +c|     R0 = dr[R7]
        +c|     dr[R7] = R0
        +c|     nop
        +c|     nop
        +c|     nop
        +c|     nop
        +c|     _exp(4, IPU_PORT_CLK_SWITCH) //returns clocks back to normal (9MHz at 90MHz clk)
        +c|     _nop
        +|     
        +c|     all
        +c|     where(dr[R7])
        +|     
        +c|     _exp(2,IPU_PORT_FALL_C1)
        +c|     _exp(7,IPU_PORT_RISE_C2) //make this a count of 2 if running at 180MHz
        +c|     _exp(8,IPU_PORT_FALL_C2)    
        +|     
        +c|     _exp(4, IPU_PORT_CLK_SWITCH)
        +c|     _nop
        +|     
        +c|     set( 'pgdb' 'pgdbobus' 'col_out' 'dir' ) //output first live column (all rows active)
        +c|     keep
        +c|     set( 'col_out' 'dir' )
        +c|     _imp(sx,234) //Get data from Dig port
        +|     
        +c|     _exp(4,IPU_PORT_CLK_SWITCH) // dreg operation clock
        +c|     _nop
        +|     
        +|     
        +c|     set( 'pgdb' 'row_out' )
        +c|     keep
        +c|     set( 'row_out' )
        +c|     _imp(sy,234)//Now have row coord of pixel found in column y=s3 x=s5
        +|     
        +|      //send coordinates
        +c|     _mov(su,255)
        +c|     _sub(su,sx)
        +m|     spi.send_byte(su)
        ++c|     _exp(ipuvar[15],IPU_PORT_NO_IPU_DO)
        +m|     spi.send_byte(sy)
        ++c|     _exp(ipuvar[11],IPU_PORT_NO_IPU_DO)
        +| 
        +|     
        +c|     _exp(2,IPU_PORT_FALL_C1)
        +c|     _exp(7,IPU_PORT_RISE_C2) //make this a count of 2 if running at 180MHz
        +c|     _exp(8,IPU_PORT_FALL_C2)    
        +|     
        +c|     _exp(4, IPU_PORT_CLK_SWITCH)
        +c|     _nop
        +|     
        +c|     set( 'pgdb' 'pgdbobus' 'col_out' ) //output last live column (all rows active)
        +c|     keep
        +c|     set( 'col_out' )  
        +c|     _imp(sx,234) //Get data from Dig port
        +|     
        +c|     _exp(4,IPU_PORT_CLK_SWITCH) // dreg operation clock
        +c|     _nop
        +|     
        +|     
        +c|     set( 'pgdb' 'row_out' 'dir' )
        +c|     keep
        +c|     set( 'row_out' 'dir' )
        +c|     _imp(sy,234)//Now have row coord of pixel found in column y=s3 x=s5
        +|     
        +|      //send coordinates
        +c|     _mov(su,255)
        +c|     _sub(su,sx)
        +m|     spi.send_byte(su)
        ++c|     _exp(ipuvar[15],IPU_PORT_NO_IPU_DO)
        +m|     spi.send_byte(sy)
        ++c|     _exp(ipuvar[11],IPU_PORT_NO_IPU_DO)
        +|     
        +|     
        +c|     _exp(8, IPU_PORT_CLK_SWITCH)
        +c|     _nop
        +c|     _exp(1,IPU_PORT_FALL_C1)
        +c|     _exp(5,IPU_PORT_FALL_C1)
        +c|     _exp(6,IPU_PORT_RISE_C2) //make this a count of 2 if running at 180MHz
        +c|     _exp(9,IPU_PORT_FALL_C2)
        +|     
        +c|     all
        +|     
        +c|     _exp(8, IPU_PORT_CLK_SWITCH)
        +c|     _nop
        +|     
        m|     spi.end
        +c|     _exp(1, 246)
        +c|     _exp(0, 246)
        +c|     _nop
        +c|     _exp(0, 253)
        c|     _nop
        |     
        |     ////////////////////////////////////
        |     
        |     //usb.aout(C ,window_1)
        |     
        | //     usb.dout(R5 ,window_3)
        | //     all
        | 
        | //  	  usb.stream_begin(data_1)
        | //         usb.stream_send(s15)
        | //         usb.stream_send(s14)
        | //    
        c| _jump(#frame_loop)
        |    
        c| apron.genereate_host
        c| apron.compile_host
    }

    >res
    {
        >generics
        {
            count = 0
        }

        >registers
        {
            >resource
            {
                name = A
                id = 0
                type = ar
                simid = 0
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = B
                id = 1
                type = ar
                simid = 1
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = C
                id = 2
                type = ar
                simid = 2
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = D
                id = 3
                type = ar
                simid = 3
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = E
                id = 4
                type = ar
                simid = 4
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = F
                id = 5
                type = ar
                simid = 5
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = NEWS
                id = 6
                type = ar
                simid = 6
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = PIX
                id = 7
                type = ar
                simid = 7
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = IN
                id = 8
                type = ar
                simid = 8
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = NORTH
                id = 9
                type = ar
                simid = 9
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = SOUTH
                id = 10
                type = ar
                simid = 10
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = EAST
                id = 11
                type = ar
                simid = 11
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = WEST
                id = 12
                type = ar
                simid = 12
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = R0
                id = 0
                type = dr
                simid = 13
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = R1
                id = 1
                type = dr
                simid = 14
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = R2
                id = 2
                type = dr
                simid = 15
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = R3
                id = 3
                type = dr
                simid = 16
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = R4
                id = 4
                type = dr
                simid = 17
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = R5
                id = 5
                type = dr
                simid = 18
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = R6
                id = 6
                type = dr
                simid = 19
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = R7
                id = 7
                type = dr
                simid = 20
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = R8
                id = 8
                type = dr
                simid = 21
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = R9
                id = 9
                type = dr
                simid = 22
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = R10
                id = 10
                type = dr
                simid = 23
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = R11
                id = 11
                type = dr
                simid = 24
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = R12
                id = 12
                type = dr
                simid = 25
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            >resource
            {
                name = FLAG
                id = 13
                type = dr
                simid = 26
                width = 128
                height = 128
                pal_name = Apron
                pal_scale = 1.000000
            }

            count = 27
        }

        >variables
        {
            >resource
            {
                name = s0
                id = 0
                type = ipuvar
                simid = 0
            }

            >resource
            {
                name = s1
                id = 1
                type = ipuvar
                simid = 1
            }

            >resource
            {
                name = s2
                id = 2
                type = ipuvar
                simid = 2
            }

            >resource
            {
                name = s3
                id = 3
                type = ipuvar
                simid = 3
            }

            >resource
            {
                name = s4
                id = 4
                type = ipuvar
                simid = 4
            }

            >resource
            {
                name = s5
                id = 5
                type = ipuvar
                simid = 5
            }

            >resource
            {
                name = s6
                id = 6
                type = ipuvar
                simid = 6
            }

            >resource
            {
                name = s7
                id = 7
                type = ipuvar
                simid = 7
            }

            >resource
            {
                name = s8
                id = 8
                type = ipuvar
                simid = 8
            }

            >resource
            {
                name = s9
                id = 9
                type = ipuvar
                simid = 9
            }

            >resource
            {
                name = s10
                id = 10
                type = ipuvar
                simid = 10
            }

            >resource
            {
                name = s11
                id = 11
                type = ipuvar
                simid = 11
            }

            >resource
            {
                name = s12
                id = 12
                type = ipuvar
                simid = 12
            }

            >resource
            {
                name = s13
                id = 13
                type = ipuvar
                simid = 13
            }

            >resource
            {
                name = s14
                id = 14
                type = ipuvar
                simid = 14
            }

            >resource
            {
                name = s15
                id = 15
                type = ipuvar
                simid = 15
            }

            >resource
            {
                name = window_1
                id = 0
                type = variable
                simid = 16
            }

            >resource
            {
                name = window_2
                id = 1
                type = variable
                simid = 17
            }

            >resource
            {
                name = window_3
                id = 2
                type = variable
                simid = 18
            }

            >resource
            {
                name = slider_1
                id = 3
                type = variable
                simid = 19
            }

            >resource
            {
                name = slider_2
                id = 4
                type = variable
                simid = 20
            }

            >resource
            {
                name = data_1
                id = 5
                type = variable
                simid = 21
            }

            count = 22
        }

        >modules
        {
            count = 0
        }

        >strings
        {
            count = 307
            string[0] = 'scamp5c/scamp5c_compile_config.aps'
            string[1] = 'cores/core_scamp5b_mod.dll'
            string[2] = 'W1'
            string[3] = 'W2'
            string[4] = 'W3'
            string[5] = 'threshold'
            string[6] = 'flood_iterations'
            string[7] = 'coords'
            string[8] = 'scamp5c/scamp5c_framework.aps'
            string[9] = 'scamp5c/scamp5c_pe_def.aps'
            string[10] = 'ar'
            string[11] = 'ar'
            string[12] = 'SIM_REGISTER'
            string[13] = 'dr'
            string[14] = 'dr'
            string[15] = 'SIM_REGISTER'
            string[16] = 'ipuvar'
            string[17] = 'iv'
            string[18] = 'SIM_VARIABLE'
            string[19] = 'ar'
            string[20] = 'dr'
            string[21] = 'ipuvar'
            string[22] = 'A'
            string[23] = 'B'
            string[24] = 'C'
            string[25] = 'D'
            string[26] = 'E'
            string[27] = 'F'
            string[28] = 'NEWS'
            string[29] = 'PIX'
            string[30] = 'IN'
            string[31] = 'NORTH'
            string[32] = 'SOUTH'
            string[33] = 'EAST'
            string[34] = 'WEST'
            string[35] = 'R0'
            string[36] = 'R1'
            string[37] = 'R2'
            string[38] = 'R3'
            string[39] = 'R4'
            string[40] = 'R5'
            string[41] = 'R6'
            string[42] = 'R7'
            string[43] = 'R8'
            string[44] = 'R9'
            string[45] = 'R10'
            string[46] = 'R11'
            string[47] = 'R12'
            string[48] = 'FLAG'
            string[49] = 'scamp5c/scamp5c_pe_macro.aps'
            string[50] = 'sin'
            string[51] = 'plrb'
            string[52] = 'rid'
            string[53] = 'plrb'
            string[54] = 'rid'
            string[55] = 'scamp5c/scamp5c_ipu_def.aps'
            string[56] = 's0'
            string[57] = 's1'
            string[58] = 's2'
            string[59] = 's3'
            string[60] = 's4'
            string[61] = 's5'
            string[62] = 's6'
            string[63] = 's7'
            string[64] = 's8'
            string[65] = 's9'
            string[66] = 's10'
            string[67] = 's11'
            string[68] = 's12'
            string[69] = 's13'
            string[70] = 's14'
            string[71] = 's15'
            string[72] = 'scamp5c/scamp5c_ipu_macro.aps'
            string[73] = 'sin'
            string[74] = 'scamp5c/scamp5c_io_macro.aps'
            string[75] = 'scamp5c/scamp5c_spi_macro.aps'
            string[76] = 'pgdb'
            string[77] = 'dig8'
            string[78] = 'pgdbobus'
            string[79] = 'sin'
            string[80] = 'LR4'
            string[81] = 'nbit'
            string[82] = 'plrb'
            string[83] = 'rfl'
            string[84] = 'lfl'
            string[85] = 'RR4'
            string[86] = 'RR3'
            string[87] = 'nbit'
            string[88] = 'plrb'
            string[89] = 'pgdb'
            string[90] = 'pgdbobus'
            string[91] = 'col_out'
            string[92] = 'col_out'
            string[93] = 'pgdb'
            string[94] = 'row_out'
            string[95] = 'row_out'
            string[96] = 'LR3'
            string[97] = 'wr'
            string[98] = 'bitmode'
            string[99] = 'bit'
            string[100] = 'plrb'
            string[101] = 'pgdb'
            string[102] = 'pgdbobus'
            string[103] = 'col_out'
            string[104] = 'dir'
            string[105] = 'col_out'
            string[106] = 'dir'
            string[107] = 'pgdb'
            string[108] = 'row_out'
            string[109] = 'row_out'
            string[110] = 'pgdb'
            string[111] = 'pgdbobus'
            string[112] = 'col_out'
            string[113] = 'col_out'
            string[114] = 'pgdb'
            string[115] = 'row_out'
            string[116] = 'dir'
            string[117] = 'row_out'
            string[118] = 'dir'
            string[119] = 'scamp5c/scamp5c_usb_macro.aps'
            string[120] = 'plrb'
            string[121] = 'rid'
            string[122] = 'plrb'
            string[123] = 'rid'
            string[124] = 'LR4'
            string[125] = 'nbit'
            string[126] = 'plrb'
            string[127] = 'rfl'
            string[128] = 'lfl'
            string[129] = 'RR4'
            string[130] = 'RR3'
            string[131] = 'nbit'
            string[132] = 'plrb'
            string[133] = 'pgdb'
            string[134] = 'pgdbobus'
            string[135] = 'col_out'
            string[136] = 'col_out'
            string[137] = 'pgdb'
            string[138] = 'row_out'
            string[139] = 'row_out'
            string[140] = 'LR3'
            string[141] = 'wr'
            string[142] = 'bitmode'
            string[143] = 'bit'
            string[144] = 'plrb'
            string[145] = 'scamp5c/scamp5c_pro_macro.aps'
            string[146] = 'RR12'
            string[147] = 'plrb'
            string[148] = 'bit'
            string[149] = 'bitmode'
            string[150] = 'LR12'
            string[151] = 'RR12'
            string[152] = 'rid'
            string[153] = 'nb'
            string[154] = 'plrb'
            string[155] = 'pupd'
            string[156] = 'float'
            string[157] = 'LR12'
            string[158] = 'RR12'
            string[159] = 'rid'
            string[160] = 'nb'
            string[161] = 'plrb'
            string[162] = 'pupd'
            string[163] = 'float'
            string[164] = 'LR12'
            string[165] = 'RR12'
            string[166] = 'rid'
            string[167] = 'nb'
            string[168] = 'plrb'
            string[169] = 'pupd'
            string[170] = 'float'
            string[171] = 'LR12'
            string[172] = 'RR12'
            string[173] = 'rid'
            string[174] = 'nb'
            string[175] = 'plrb'
            string[176] = 'pupd'
            string[177] = 'float'
            string[178] = 'LR12'
            string[179] = 'RR12'
            string[180] = 'rid'
            string[181] = 'nb'
            string[182] = 'plrb'
            string[183] = 'pupd'
            string[184] = 'float'
            string[185] = 'LR12'
            string[186] = 'RR12'
            string[187] = 'rid'
            string[188] = 'nb'
            string[189] = 'plrb'
            string[190] = 'pupd'
            string[191] = 'float'
            string[192] = 'LR12'
            string[193] = 'RR12'
            string[194] = 'rid'
            string[195] = 'nb'
            string[196] = 'plrb'
            string[197] = 'pupd'
            string[198] = 'float'
            string[199] = 'LR12'
            string[200] = 'RR12'
            string[201] = 'rid'
            string[202] = 'nb'
            string[203] = 'plrb'
            string[204] = 'pupd'
            string[205] = 'float'
            string[206] = 'RR12'
            string[207] = 'plrb'
            string[208] = 'bit'
            string[209] = 'bitmode'
            string[210] = 'LR12'
            string[211] = 'RR12'
            string[212] = 'rid'
            string[213] = 'nb'
            string[214] = 'plrb'
            string[215] = 'float'
            string[216] = 'LR12'
            string[217] = 'RR12'
            string[218] = 'rid'
            string[219] = 'nb'
            string[220] = 'plrb'
            string[221] = 'float'
            string[222] = 'LR12'
            string[223] = 'RR12'
            string[224] = 'rid'
            string[225] = 'nb'
            string[226] = 'plrb'
            string[227] = 'float'
            string[228] = 'LR12'
            string[229] = 'RR12'
            string[230] = 'rid'
            string[231] = 'nb'
            string[232] = 'plrb'
            string[233] = 'float'
            string[234] = 'LR12'
            string[235] = 'RR12'
            string[236] = 'rid'
            string[237] = 'nb'
            string[238] = 'plrb'
            string[239] = 'float'
            string[240] = 'RR3'
            string[241] = 'south'
            string[242] = 'east'
            string[243] = 'pgdb'
            string[244] = 'pgdbobus'
            string[245] = 'col_out'
            string[246] = 'col_out'
            string[247] = 'pgdb'
            string[248] = 'row_out'
            string[249] = 'row_out'
            string[250] = 'pgdb'
            string[251] = 'pgdbobus'
            string[252] = 'col_out'
            string[253] = 'dir'
            string[254] = 'sin'
            string[255] = 'col_out'
            string[256] = 'dir'
            string[257] = 'pgdb'
            string[258] = 'row_out'
            string[259] = 'row_out'
            string[260] = 'pgdb'
            string[261] = 'pgdbobus'
            string[262] = 'col_out'
            string[263] = 'sin'
            string[264] = 'col_out'
            string[265] = 'pgdb'
            string[266] = 'row_out'
            string[267] = 'dir'
            string[268] = 'row_out'
            string[269] = 'dir'
            string[270] = 'g_start'
            string[271] = 'g_stop'
            string[272] = 'wr'
            string[273] = 'plrb'
            string[274] = 'bit'
            string[275] = 'bitmode'
            string[276] = 's0_left'
            string[277] = 's0_bot'
            string[278] = 'pgdb'
            string[279] = 'pgdbobus'
            string[280] = 'col_out'
            string[281] = 'dig8'
            string[282] = 'scamp5c/scamp5c_calibration.aps'
            string[283] = 'wrf'
            string[284] = 'SEL1'
            string[285] = 'ana'
            string[286] = 'SEL7'
            string[287] = 'ana'
            string[288] = 'SEL1'
            string[289] = 'ana'
            string[290] = 'scamp5c/scamp5c_host_and_sim.aps'
            string[291] = 'scamp5c/scamp5c_routine.aps'
            string[292] = 'sin'
            string[293] = 'lfl'
            string[294] = 'wr'
            string[295] = 'bitmode'
            string[296] = 'bit'
            string[297] = 'plrb'
            string[298] = 'lfl'
            string[299] = 'wr'
            string[300] = 'bitmode'
            string[301] = 'bit'
            string[302] = 'plrb'
            string[303] = 'pgdb'
            string[304] = 'dig8'
            string[305] = 'pgdbobus'
            string[306] = 'sin'
        }

    }

    >bin
    {
        --- 0
        --- 0
        --- 0
        --- 0
        --- 0
        --- 0
        --- 0
        --- 0
        --- 0
        --- 1
        00000000000000000000000000000000
        --- 1
        00460003FFDC00000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0046000007D000000000000000000000
        --- 1
        004600001FE000000000000000000000
        --- 1
        00460000022800000000000000000000
        --- 1
        0046000007CC00000000000000000000
        --- 1
        0046000003CC00000000000000000000
        --- 1
        0046000007C800000000000000000000
        --- 1
        0046000003C800000000000000000000
        --- 1
        0046000023B000000000000000000000
        --- 1
        00460000FE2800000000000000000000
        --- 1
        0046000007C400000000000000000000
        --- 1
        0046000003C400000000000000000000
        --- 1
        0046000007C000000000000000000000
        --- 1
        0046000003C000000000000000000000
        --- 1
        134001ECF00000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        004600001FE000000000000000000000
        --- 1
        0046000003C000000000000000000000
        --- 1
        0106002C022800000000000000000000
        --- 1
        0046000007C400000000000000000000
        --- 1
        0046000003C400000000000000000000
        --- 1
        01060030022800000000000000000000
        --- 1
        0046000007C000000000000000000000
        --- 1
        134001F0000000000000000000000000
        --- 1
        01060030022800000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        004600001BE000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        1F4000B0040000000000000000000000
        --- 1
        00002601800000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        004600001FE000000000000000000000
        --- 1
        01060030022800000000000000000000
        --- 1
        004600001BE000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        1D4000F0FC0000000000000000000000
        --- 1
        00001000B80000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        1F4000AC040000000000000000000000
        --- 1
        1D4000ECFC0000000000000000000000
        --- 1
        00001000440000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00200000000000000000000000000000
        --- 1
        00000606040000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        134001FC140000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        134001FBFC0000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        1F4000F8040000000000000000000000
        --- 1
        00001001180000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        1F4000FC040000000000000000000000
        --- 1
        00001001100000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00200000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        4046000003BC00000000000000000000
        --- 0
        --- 1
        E0000000000000000000000000000020
        --- 1
        0046000083DC00000000000000000000
        --- 1
        0046000007D000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        134001F8240000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        1F4000F8040000000000000000000000
        --- 1
        00001001540000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        1F4000FC040000000000000000000000
        --- 1
        000010014C0000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0046000023DC00000000000000000000
        --- 1
        0046000003D000000000000000000000
        --- 1
        00200000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0046000007B400000000000000000000
        --- 1
        0302003403B800000000000000000000
        --- 1
        17400034040000000000000000000000
        --- 1
        00000801840000000000000000000000
        --- 1
        0046000003B400000000000000000000
        --- 1
        03020034038400000000000000000000
        --- 1
        00200000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0046000007D000000000000000000000
        --- 1
        00460003FFDC00000000000000000000
        --- 1
        0106002C022800000000000000000000
        --- 1
        0046000007C400000000000000000000
        --- 1
        0046000003C400000000000000000000
        --- 1
        134001FFFC0000000000000000000000
        --- 1
        1F0000FF000000000000000000000000
        --- 1
        0106003C022800000000000000000000
        --- 1
        0046000007C000000000000000000000
        --- 1
        0046000003C000000000000000000000
        --- 1
        00460000022800000000000000000000
        --- 1
        0046000007C800000000000000000000
        --- 1
        0046000003C800000000000000000000
        --- 1
        0046000007CC00000000000000000000
        --- 1
        0046000003CC00000000000000000000
        --- 1
        0046000013DC00000000000000000000
        --- 1
        4046000003D000000000000000000000
        --- 1
        C000000000000001E100000000000000
        --- 1
        0046000007D000000000000000000000
        --- 1
        00460003FFDC00000000000000000000
        --- 1
        0046000023DC00000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0046000003D000000000000000000000
        --- 1
        00200000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00460003FFDC00000000000000000000
        --- 1
        0106002C022800000000000000000000
        --- 1
        0046000007C400000000000000000000
        --- 1
        0046000003C400000000000000000000
        --- 1
        01060030022800000000000000000000
        --- 1
        0046000007C000000000000000000000
        --- 1
        0046000003C000000000000000000000
        --- 1
        0106003C022800000000000000000000
        --- 1
        0046000007C800000000000000000000
        --- 1
        0046000003C800000000000000000000
        --- 1
        01060038022800000000000000000000
        --- 1
        0046000007CC00000000000000000000
        --- 1
        0046000003CC00000000000000000000
        --- 1
        0046000003D000000000000000000000
        --- 1
        0046000013DC00000000000000000000
        --- 1
        004600001A3400000000000000000000
        --- 1
        40460000163000000000000000000000
        --- 1
        C000000000000001E100000000000000
        --- 1
        0046000023DC00000000000000000000
        --- 1
        00200000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00460003FFDC00000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        004600001FE000000000000000000000
        --- 1
        0302003C038000000000000000000000
        --- 1
        1740003C040000000000000000000000
        --- 1
        00001002680000000000000000000000
        --- 1
        00460001578800000000000000000000
        --- 1
        0302003C038000000000000000000000
        --- 1
        1740003C040000000000000000000000
        --- 1
        00001002780000000000000000000000
        --- 1
        004600001B8800000000000000000000
        --- 1
        0302003C038000000000000000000000
        --- 1
        1740003C040000000000000000000000
        --- 1
        00001002880000000000000000000000
        --- 1
        00460000038800000000000000000000
        --- 1
        0302003C038000000000000000000000
        --- 1
        1740003C040000000000000000000000
        --- 1
        00001002980000000000000000000000
        --- 1
        00460000038800000000000000000000
        --- 1
        0302003C038000000000000000000000
        --- 1
        1740003C040000000000000000000000
        --- 1
        00001002A80000000000000000000000
        --- 1
        00460003FF8800000000000000000000
        --- 1
        0302003C038000000000000000000000
        --- 1
        1740003C040000000000000000000000
        --- 1
        00001002B80000000000000000000000
        --- 1
        00460003FF8800000000000000000000
        --- 1
        00460000022800000000000000000000
        --- 1
        0046000007CC00000000000000000000
        --- 1
        0046000003CC00000000000000000000
        --- 1
        0046000007C800000000000000000000
        --- 1
        0046000003C800000000000000000000
        --- 1
        0046000023B000000000000000000000
        --- 1
        0046000007D000000000000000000000
        --- 1
        00460000022800000000000000000000
        --- 1
        0046000007C400000000000000000000
        --- 1
        0046000003C400000000000000000000
        --- 1
        134001EC000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        004600001FE000000000000000000000
        --- 1
        0106002C022800000000000000000000
        --- 1
        0046000007C400000000000000000000
        --- 1
        0046000003C400000000000000000000
        --- 1
        134001F0000000000000000000000000
        --- 1
        01060030022800000000000000000000
        --- 1
        0046000007C000000000000000000000
        --- 1
        004600001BE000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        1F4000B0040000000000000000000000
        --- 1
        00002601800000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        004600001FE000000000000000000000
        --- 1
        01060030022800000000000000000000
        --- 1
        004600001BE000000000000000000000
        --- 1
        0302003C038000000000000000000000
        --- 1
        1740003C040000000000000000000000
        --- 1
        00001003780000000000000000000000
        --- 1
        01060034038800000000000000000000
        --- 1
        1D4000F0000000000000000000000000
        --- 1
        000010035C0000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        1F4000AC040000000000000000000000
        --- 1
        00001002F40000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0046000023DC00000000000000000000
        --- 1
        0046000003D000000000000000000000
        --- 1
        00200000000000000000000000000000
        --- 1
        0046000023DC00000000000000000000
        --- 1
        4046000003BC00000000000000000000
        --- 0
        --- 1
        E00000000000C0040000000000000020
        --- 1
        00460003FFDC00000000000000000000
        --- 1
        0046000003D000000000000000000000
        --- 1
        0302003C038000000000000000000000
        --- 1
        1740003C040000000000000000000000
        --- 1
        00001003C00000000000000000000000
        --- 1
        00460001578800000000000000000000
        --- 1
        0302003C038000000000000000000000
        --- 1
        1740003C040000000000000000000000
        --- 1
        00001003D00000000000000000000000
        --- 1
        00460000238800000000000000000000
        --- 1
        0302003C038000000000000000000000
        --- 1
        1740003C040000000000000000000000
        --- 1
        00001003E00000000000000000000000
        --- 1
        00460000038800000000000000000000
        --- 1
        0302003C038000000000000000000000
        --- 1
        1740003C040000000000000000000000
        --- 1
        00001003F00000000000000000000000
        --- 1
        00460000038800000000000000000000
        --- 1
        0302003C038000000000000000000000
        --- 1
        1740003C040000000000000000000000
        --- 1
        00001004000000000000000000000000
        --- 1
        00460003FF8800000000000000000000
        --- 1
        0302003C038000000000000000000000
        --- 1
        1740003C040000000000000000000000
        --- 1
        00001004100000000000000000000000
        --- 1
        00460003FF8800000000000000000000
        --- 1
        00460000022800000000000000000000
        --- 1
        0046000007CC00000000000000000000
        --- 1
        0046000003CC00000000000000000000
        --- 1
        004600001E2800000000000000000000
        --- 1
        0046000007C800000000000000000000
        --- 1
        0046000003C800000000000000000000
        --- 1
        134001EC000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0106002C022800000000000000000000
        --- 1
        0046000007C400000000000000000000
        --- 1
        0046000003C400000000000000000000
        --- 1
        134001F0000000000000000000000000
        --- 1
        0046000007C000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        01060030022800000000000000000000
        --- 1
        0046000013DC00000000000000000000
        --- 1
        0046000007D000000000000000000000
        --- 1
        00460003FFDC00000000000000000000
        --- 1
        0302003403A800000000000000000000
        --- 1
        0046000003D000000000000000000000
        --- 1
        0302003C038000000000000000000000
        --- 1
        1740003C040000000000000000000000
        --- 1
        00001004700000000000000000000000
        --- 1
        01060034038800000000000000000000
        --- 1
        1F4000B0200000000000000000000000
        --- 1
        00001004540000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        1F4000AC040000000000000000000000
        --- 1
        000010043C0000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0046000003C000000000000000000000
        --- 1
        0046000023DC00000000000000000000
        --- 1
        0046000003D000000000000000000000
        --- 1
        00200000000000000000000000000000
        --- 1
        00460000022800000000000000000000
        --- 1
        0046000007CC00000000000000000000
        --- 1
        0046000003CC00000000000000000000
        --- 1
        0046000007C800000000000000000000
        --- 1
        0046000003C800000000000000000000
        --- 1
        0046000023B000000000000000000000
        --- 1
        0046000007D000000000000000000000
        --- 1
        00460000022800000000000000000000
        --- 1
        0046000007C400000000000000000000
        --- 1
        0046000003C400000000000000000000
        --- 1
        134001EC000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        004600001FE000000000000000000000
        --- 1
        0106002C022800000000000000000000
        --- 1
        0046000007C400000000000000000000
        --- 1
        0046000003C400000000000000000000
        --- 1
        134001F0000000000000000000000000
        --- 1
        01060030022800000000000000000000
        --- 1
        0046000007C000000000000000000000
        --- 1
        004600001BE000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        1F0000B3800000000000000000000000
        --- 1
        00002601800000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        004600001FE000000000000000000000
        --- 1
        01060030022800000000000000000000
        --- 1
        004600001BE000000000000000000000
        --- 1
        0302003C038000000000000000000000
        --- 1
        1740003C100000000000000000000000
        --- 1
        00001005580000000000000000000000
        --- 1
        01060034038800000000000000000000
        --- 1
        1D4000F0000000000000000000000000
        --- 1
        000010053C0000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        1F0000AF800000000000000000000000
        --- 1
        00001004D40000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00200000000000000000000000000000
        --- 1
        00460000022800000000000000000000
        --- 1
        0046000007CC00000000000000000000
        --- 1
        0046000003CC00000000000000000000
        --- 1
        004600001E2800000000000000000000
        --- 1
        0046000007C800000000000000000000
        --- 1
        0046000003C800000000000000000000
        --- 1
        134001EC000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0106002C022800000000000000000000
        --- 1
        0046000007C400000000000000000000
        --- 1
        0046000003C400000000000000000000
        --- 1
        134001F0000000000000000000000000
        --- 1
        0046000007C000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        01060030022800000000000000000000
        --- 1
        0046000013DC00000000000000000000
        --- 1
        0046000007D000000000000000000000
        --- 1
        00460003FFDC00000000000000000000
        --- 1
        0302003403A800000000000000000000
        --- 1
        0046000003D000000000000000000000
        --- 1
        0302003C038000000000000000000000
        --- 1
        1740003C100000000000000000000000
        --- 1
        00001005D40000000000000000000000
        --- 1
        01060034038800000000000000000000
        --- 1
        1F4000B0200000000000000000000000
        --- 1
        00001005B80000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        1F4000AC040000000000000000000000
        --- 1
        00001005A00000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0046000003C000000000000000000000
        --- 1
        00200000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        134001C4000000000000000000000000
        --- 1
        0302003C000C00000000000000000000
        --- 1
        0106003C022C00000000000000000000
        --- 1
        0302003C001000000000000000000000
        --- 1
        0106003C023000000000000000000000
        --- 1
        0302003C001400000000000000000000
        --- 1
        0106003C023400000000000000000000
        --- 1
        0302003C001800000000000000000000
        --- 1
        0106003C023800000000000000000000
        --- 1
        0302003C001C00000000000000000000
        --- 1
        0106003C023C00000000000000000000
        --- 1
        0302003C002000000000000000000000
        --- 1
        0106003C024000000000000000000000
        --- 1
        0302003C002400000000000000000000
        --- 1
        0106003C024400000000000000000000
        --- 1
        0302003C002800000000000000000000
        --- 1
        0106003C024800000000000000000000
        --- 1
        0302003C002C00000000000000000000
        --- 1
        0106003C024C00000000000000000000
        --- 1
        0302003C003000000000000000000000
        --- 1
        0106003C025000000000000000000000
        --- 1
        0302003C003400000000000000000000
        --- 1
        0106003C025400000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        004600004FF000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        004600001FE000000000000000000000
        --- 1
        0046000083DC00000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        004600004FF000000000000000000000
        --- 1
        004600006FF000000000000000000000
        --- 1
        0046000067F000000000000000000000
        --- 1
        00002601080000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00460000E7F000000000000000000000
        --- 1
        00460001E7F000000000000000000000
        --- 1
        00460003E7F000000000000000000000
        --- 1
        00460003E3F000000000000000000000
        --- 1
        00002601080000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00002601080000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00002601080000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00002601080000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00460003F3F000000000000000000000
        --- 1
        0046000083DC00000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0046000013DC00000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0046000003EC00000000000000000000
        --- 1
        0046000003D000000000000000000000
        --- 1
        0046000023E400000000000000000000
        --- 1
        004600011BBC00000000000000000000
        --- 1
        0046000027E400000000000000000000
        --- 1
        004600013FBC00000000000000000000
        --- 1
        004600002BE400000000000000000000
        --- 1
        004600034FBC00000000000000000000
        --- 1
        004600002FE400000000000000000000
        --- 1
        004600027BBC00000000000000000000
        --- 1
        0046000033E400000000000000000000
        --- 1
        004600034FBC00000000000000000000
        --- 1
        0046000037E400000000000000000000
        --- 1
        004600010FBC00000000000000000000
        --- 1
        004600003BE400000000000000000000
        --- 1
        00460000FFBC00000000000000000000
        --- 1
        004600003FE400000000000000000000
        --- 1
        004600011BBC00000000000000000000
        --- 1
        0046000043E400000000000000000000
        --- 1
        00460003ABBC00000000000000000000
        --- 1
        0046000047E400000000000000000000
        --- 1
        004600011FBC00000000000000000000
        --- 1
        004600004BE400000000000000000000
        --- 1
        00460001EBBC00000000000000000000
        --- 1
        00460003E3E800000000000000000000
        --- 1
        004600004FE400000000000000000000
        --- 1
        0046000113BC00000000000000000000
        --- 1
        0046000003E800000000000000000000
        --- 1
        0046000053E400000000000000000000
        --- 1
        004600005FBC00000000000000000000
        --- 1
        0046000057E400000000000000000000
        --- 1
        004600017BBC00000000000000000000
        --- 1
        004600005BE400000000000000000000
        --- 1
        0046000293BC00000000000000000000
        --- 1
        004600005FE400000000000000000000
        --- 1
        00460001D7BC00000000000000000000
        --- 1
        0046000003E400000000000000000000
        --- 1
        00002601080000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00002601080000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0046000023DC00000000000000000000
        --- 1
        0046000003D000000000000000000000
        --- 1
        40000000000000000000000000000000
        --- 1
        80000000000000000000000000100000
        --- 1
        C0000000000000000000000010000000
        --- 1
        134001D9980000000000000000000000
        --- 1
        0106001803BC00000000000000000000
        --- 1
        004600004BE400000000000000000000
        --- 1
        0106001803BC00000000000000000000
        --- 1
        00002601080000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00002601080000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00002601080000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00002601080000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00002601080000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00002601080000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00002601080000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00002601080000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00002601080000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        134001D7C00000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        004600001BE000000000000000000000
        --- 1
        0046000023DC00000000000000000000
        --- 1
        0046000003D000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00002601080000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0106001803BC00000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0106001403E800000000000000000000
        --- 1
        40000000000000000000000000000000
        --- 1
        80000000000000000000000000202000
        --- 0
        --- 1
        E0000000000000020000000000200000
        --- 1
        00002600000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        1F4000B6100000000000000000000000
        --- 1
        000002085C0000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        1F400094040000000000000000000000
        --- 1
        00001007F80000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        1F400098040000000000000000000000
        --- 1
        00001007F00000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        004600005FE400000000000000000000
        --- 1
        0046000003E400000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        134001C4200000000000000000000000
        --- 1
        1D4000C4200000000000000000000000
        --- 1
        00000808940000000000000000000000
        --- 1
        00460000024400000000000000000000
        --- 1
        004600002A4800000000000000000000
        --- 1
        00460000022C00000000000000000000
        --- 1
        004600001A3000000000000000000000
        --- 1
        004600001A3400000000000000000000
        --- 1
        004600002A3800000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0106000403DC00000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        4046000003E400000000000000000000
        --- 1
        C0000000000000000000000010000000
        --- 1
        00460000022800000000000000000000
        --- 1
        0046000007CC00000000000000000000
        --- 1
        0046000003CC00000000000000000000
        --- 1
        0046000007C800000000000000000000
        --- 1
        0046000003C800000000000000000000
        --- 1
        0046000023B000000000000000000000
        --- 1
        00460000FE2800000000000000000000
        --- 1
        0046000007C400000000000000000000
        --- 1
        0046000007C000000000000000000000
        --- 1
        004600001BE000000000000000000000
        --- 1
        0046000007EC00000000000000000000
        --- 1
        134001DBFC0000000000000000000000
        --- 1
        004600003FE800000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        1F4000D8040000000000000000000000
        --- 1
        0046000003D000000000000000000000
        --- 1
        4106001803BC00000000000000000000
        --- 1
        C0000000000000000000000008080000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        40000000000000000000000000000000
        --- 1
        80000000000000000000000008080020
        --- 0
        --- 1
        E0000000000000020000000008000000
        --- 1
        00002600000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0106000403DC00000000000000000000
        --- 1
        0046000003D000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        1F4000B6000000000000000000000000
        --- 1
        00000408DC0000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        130001D1800000000000000000000000
        --- 1
        134001DBFC0000000000000000000000
        --- 1
        0106001003BC00000000000000000000
        --- 1
        134001E4000000000000000000000000
        --- 1
        00002601080000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        134001DBFC0000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        134001D7FC0000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0106001403E800000000000000000000
        --- 1
        4106001003BC00000000000000000000
        --- 1
        C0000000000000000000000008282000
        --- 1
        40000000000000000000000000000000
        --- 1
        C0000000000000000000000008080020
        --- 1
        4106001803BC00000000000000000000
        --- 1
        80000000000000000000000008202020
        --- 0
        --- 1
        E0000000000000020000000000200000
        --- 1
        00002600000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        1F0000F6400000000000000000000000
        --- 1
        00000209A00000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        004600000FEC00000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0046000007EC00000000000000000000
        --- 1
        1D4000E7FC0000000000000000000000
        --- 1
        00000809D00000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        1F4000A4040000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0106000403DC00000000000000000000
        --- 1
        0046000003D000000000000000000000
        --- 1
        0106001003BC00000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        1F4000D4080000000000000000000000
        --- 1
        1D4000D7C40000000000000000000000
        --- 1
        00001009480000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        1F4000D8040000000000000000000000
        --- 1
        00001009400000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0046000003EC00000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00460000008000000000000000000000
        --- 1
        00460000008400000000000000000000
        --- 1
        00460000008800000000000000000000
        --- 1
        00460000008C00000000000000000000
        --- 1
        0046000013F400000000000000000000
        --- 1
        0046000003F400000000000000000000
        --- 1
        00460003FFDC00000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0046000007F400000000000000000000
        --- 1
        134001F80C0000000000000000000000
        --- 1
        1F4000B8080000000000000000000000
        --- 1
        1F4000B8500000000000000000000000
        --- 1
        1F4000B8000000000000000000000000
        --- 1
        00460000838800000000000000000000
        --- 1
        004600005B8800000000000000000000
        --- 1
        00460002AB8800000000000000000000
        --- 1
        004600000F8800000000000000000000
        --- 1
        004600000B8800000000000000000000
        --- 1
        00460000538800000000000000000000
        --- 1
        00460000038800000000000000000000
        --- 1
        01060038038800000000000000000000
        --- 1
        0046000007D800000000000000000000
        --- 1
        0046000003D800000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0046000003F400000000000000000000
        --- 1
        0046000023DC00000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        134001FD900000000000000000000000
        --- 1
        00002601380000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        134001FD900000000000000000000000
        --- 1
        00002601380000000000000000000000
        --- 1
        40000000000000000000000000000000
        --- 1
        80000000000000000000000000404002
        --- 1
        80000000000000000000000008080002
        --- 1
        80000000000000000000000010000006
        --- 1
        80000000000000000000000000000000
        --- 1
        80000000000000000000000008C08002
        --- 1
        C0000000000000000000000008404002
        --- 1
        0302003C004800000000000000000000
        --- 1
        130001C3C00000000000000000000000
        --- 1
        1D4000C0000000000000000000000000
        --- 1
        130001FC000000000000000000000000
        --- 1
        4046000203BC00000000000000000000
        --- 1
        C0000000000000000000000000000020
        --- 1
        5F4000BE000000000000000000000000
        --- 1
        C0000000000000000000000008080020
        --- 1
        4106003C03BC00000000000000000000
        --- 1
        8000000000000000000000000C040020
        --- 1
        80000000000000000000000008880000
        --- 1
        8000000000000000000000000E020000
        --- 1
        80000000000000002000000002100000
        --- 1
        8000000000000000F001000000000040
        --- 1
        80000000000000000000000010000000
        --- 1
        C000000000000000F004000000000000
        --- 1
        134001EC000000000000000000000000
        --- 1
        134001F0000000000000000000000000
        --- 1
        134001FC000000000000000000000000
        --- 1
        134001FBFC0000000000000000000000
        --- 1
        00002602040000000000000000000000
        --- 1
        40000000000000000000000000000000
        --- 1
        C000000000000000F220000000000000
        --- 1
        134001EC000000000000000000000000
        --- 1
        134001F3FC0000000000000000000000
        --- 1
        134001FC000000000000000000000000
        --- 1
        134001FBFC0000000000000000000000
        --- 1
        00002602040000000000000000000000
        --- 1
        40000000000000000000000000000000
        --- 1
        8000000000000000F240000000000000
        --- 1
        C000000000000000F004060000000000
        --- 1
        134001EC000000000000000000000000
        --- 1
        134001F0000000000000000000000000
        --- 1
        134001FFFC0000000000000000000000
        --- 1
        134001F8000000000000000000000000
        --- 1
        00002602040000000000000000000000
        --- 1
        40000000000000000000000000000000
        --- 1
        8000000000000000F220000000000000
        --- 1
        C000000000000000F040024000000000
        --- 1
        134001EFFC0000000000000000000000
        --- 1
        134001F0000000000000000000000000
        --- 1
        134001FFFC0000000000000000000000
        --- 1
        134001F8000000000000000000000000
        --- 1
        00002602040000000000000000000000
        --- 1
        40000000000000000000000000000000
        --- 1
        8000000000000000F220000000000000
        --- 1
        8000000000000000F004060000000000
        --- 1
        8000000000000000F020001000000000
        --- 1
        C0000000000000003401020000000000
        --- 1
        0302003C004C00000000000000000000
        --- 1
        130001D7C00000000000000000000000
        --- 1
        1D4000D4000000000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0046000013DC00000000000000000000
        --- 1
        40000000000000000000000000000000
        --- 1
        80000000000000001100000000000000
        --- 1
        80000000000000001000100000000000
        --- 1
        80000000000000001000200000000000
        --- 1
        80000000000000001000400000000000
        --- 1
        80000000000000001000800000000000
        --- 1
        8000000000000000F080004000000000
        --- 1
        8000000000000000F100001000000000
        --- 1
        C000000000000000E000080000000000
        --- 1
        4046000013DC00000000000000000000
        --- 1
        C0000000000000002880080080000800
        --- 1
        40460000023400000000000000000000
        --- 1
        80000000000000002880080080000800
        --- 1
        80000000000000002880080080000800
        --- 1
        80000000000000002880080080000800
        --- 1
        C0000000000000002880080080000800
        --- 1
        00460000123400000000000000000000
        --- 1
        0046000023DC00000000000000000000
        --- 1
        4046000003D000000000000000000000
        --- 1
        C000000000000000F020080000000000
        --- 1
        0046000013DC00000000000000000000
        --- 1
        40000000000000000000000000000000
        --- 1
        80000000000000001100000000000000
        --- 1
        80000000000000001000100000000000
        --- 1
        80000000000000001000200000000000
        --- 1
        80000000000000001000400000000000
        --- 1
        80000000000000001000800000000000
        --- 1
        8000000000000000F080020000000000
        --- 1
        8000000000000000F100001000000000
        --- 1
        C000000000000000E000080000000000
        --- 1
        4046000013DC00000000000000000000
        --- 1
        C0000000000000002880080080000800
        --- 1
        40460000023400000000000000000000
        --- 1
        80000000000000002880080080000800
        --- 1
        80000000000000002880080080000800
        --- 1
        80000000000000002880080080000800
        --- 1
        C0000000000000002880080080000800
        --- 1
        00460000123400000000000000000000
        --- 1
        0046000023DC00000000000000000000
        --- 1
        4046000003D000000000000000000000
        --- 1
        C000000000000000F040080000000000
        --- 1
        0046000013DC00000000000000000000
        --- 1
        40000000000000000000000000000000
        --- 1
        80000000000000001100000000000000
        --- 1
        80000000000000001000100000000000
        --- 1
        80000000000000001000200000000000
        --- 1
        80000000000000001000400000000000
        --- 1
        80000000000000001000800000000000
        --- 1
        8000000000000000F080040000000000
        --- 1
        8000000000000000F100001000000000
        --- 1
        C000000000000000E000080000000000
        --- 1
        4046000013DC00000000000000000000
        --- 1
        C0000000000000002880080080000800
        --- 1
        40460000023400000000000000000000
        --- 1
        80000000000000002880080080000800
        --- 1
        80000000000000002880080080000800
        --- 1
        80000000000000002880080080000800
        --- 1
        C0000000000000002880080080000800
        --- 1
        00460000123400000000000000000000
        --- 1
        0046000023DC00000000000000000000
        --- 1
        4046000003D000000000000000000000
        --- 1
        C000000000000000F020080000000000
        --- 1
        0046000013DC00000000000000000000
        --- 1
        40000000000000000000000000000000
        --- 1
        80000000000000001100000000000000
        --- 1
        80000000000000001000100000000000
        --- 1
        80000000000000001000200000000000
        --- 1
        80000000000000001000400000000000
        --- 1
        80000000000000001000800000000000
        --- 1
        8000000000000000F080020000000000
        --- 1
        8000000000000000F100001000000000
        --- 1
        C000000000000000E000080000000000
        --- 1
        4046000013DC00000000000000000000
        --- 1
        C0000000000000002880080080000800
        --- 1
        40460000023400000000000000000000
        --- 1
        80000000000000002880080080000800
        --- 1
        80000000000000002880080080000800
        --- 1
        80000000000000002880080080000800
        --- 1
        C0000000000000002880080080000800
        --- 1
        00460000123400000000000000000000
        --- 1
        0046000023DC00000000000000000000
        --- 1
        4046000003D000000000000000000000
        --- 1
        8000000000000000F040080000000000
        --- 1
        8000000000000000F004040000000000
        --- 1
        80000000000000003420040000000000
        --- 1
        80000000000000003410001000000000
        --- 1
        80000000000000003401020000000000
        --- 1
        8000000000000000F100011000000000
        --- 1
        80000000000000003401010000000000
        --- 1
        80000000000000003610000000000000
        --- 1
        C0000000000000003401010000000000
        --- 1
        1F4000D4040000000000000000000000
        --- 1
        4000040B480000000000000000000000
        --- 1
        C0000000000000003404001000000000
        --- 1
        0046000007F400000000000000000000
        --- 1
        00460003FFDC00000000000000000000
        --- 1
        0046000007D000000000000000000000
        --- 1
        00460000838800000000000000000000
        --- 1
        004600005B8800000000000000000000
        --- 1
        00460002AB8800000000000000000000
        --- 1
        004600001F8800000000000000000000
        --- 1
        00460000238800000000000000000000
        --- 1
        00460000038800000000000000000000
        --- 1
        00460000038800000000000000000000
        --- 1
        004600003F8800000000000000000000
        --- 1
        03020038008000000000000000000000
        --- 1
        01060038038800000000000000000000
        --- 1
        03020038008400000000000000000000
        --- 1
        01060038038800000000000000000000
        --- 1
        03020038008800000000000000000000
        --- 1
        01060038038800000000000000000000
        --- 1
        03020038008C00000000000000000000
        --- 1
        01060038038800000000000000000000
        --- 1
        00460003FE2800000000000000000000
        --- 1
        0046000007CC00000000000000000000
        --- 1
        0046000003CC00000000000000000000
        --- 1
        00460003FE2800000000000000000000
        --- 1
        0046000007C800000000000000000000
        --- 1
        0046000003C800000000000000000000
        --- 1
        00460000022800000000000000000000
        --- 1
        0046000007C000000000000000000000
        --- 1
        0046000003C000000000000000000000
        --- 1
        0046000007C400000000000000000000
        --- 1
        0046000003C400000000000000000000
        --- 1
        0046000023DC00000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0046000003D000000000000000000000
        --- 1
        40000000000000000000000000000000
        --- 1
        8000000000000000F100004000000000
        --- 1
        8000000000000000F204000000000000
        --- 1
        80000000000000000000000000000000
        --- 1
        80000000000000000000000000000000
        --- 1
        80000000000000000000000000000000
        --- 1
        C0000000000000000000000000000000
        --- 1
        0046000013DC00000000000000000000
        --- 1
        40000000000000000000000000000000
        --- 1
        80000000000000000000000010000000
        --- 1
        C0000000000000002000004000100800
        --- 1
        004600000A3000000000000000000000
        --- 1
        004600001E3400000000000000000000
        --- 1
        00460000223800000000000000000000
        --- 1
        0046000013DC00000000000000000000
        --- 1
        40000000000000000000000000000000
        --- 1
        800000000000C0600000000000000000
        --- 0
        --- 1
        E0000000000000600000000000000000
        --- 1
        0302003003A800000000000000000000
        --- 1
        0046000013DC00000000000000000000
        --- 1
        40000000000000000000000000000000
        --- 1
        80000000000040800000000000000000
        --- 0
        --- 1
        E0000000000000800000000000000000
        --- 1
        0302002C03A800000000000000000000
        --- 1
        134001FFFC0000000000000000000000
        --- 1
        1F0000FF000000000000000000000000
        --- 1
        0106003C038800000000000000000000
        --- 1
        0106002C038800000000000000000000
        --- 1
        004600000A3000000000000000000000
        --- 1
        004600001E3400000000000000000000
        --- 1
        00460000223800000000000000000000
        --- 1
        0046000013DC00000000000000000000
        --- 1
        40000000000000000000000000000000
        --- 1
        800000000000C0200000000000000000
        --- 0
        --- 1
        E0000000000000200000000000000000
        --- 1
        0302003003A800000000000000000000
        --- 1
        0046000013DC00000000000000000000
        --- 1
        40000000000000000000000000000000
        --- 1
        80000000000040C00000000000000000
        --- 0
        --- 1
        E0000000000000C00000000000000000
        --- 1
        0302002C03A800000000000000000000
        --- 1
        134001FFFC0000000000000000000000
        --- 1
        1F0000FF000000000000000000000000
        --- 1
        0106003C038800000000000000000000
        --- 1
        0106002C038800000000000000000000
        --- 1
        0046000023DC00000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        00460000063000000000000000000000
        --- 1
        00460000163000000000000000000000
        --- 1
        004600001A3400000000000000000000
        --- 1
        40460000263800000000000000000000
        --- 1
        C0000000000000000000000010000000
        --- 1
        0046000023DC00000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0046000007D800000000000000000000
        --- 1
        0046000003D800000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0046000003F400000000000000000000
        --- 1
        00000000000000000000000000000000
        --- 1
        0000060A480000000000000000000000
        --- 0
        --- 0
    }

    >config
    {
        >externals
        {
        }

        >device
        {
            device = apron
        }

        >icw
        {
            >fragments
            {
                count = 0
            }

            width_bytes = 16
            count = 931
        }

    }

}

